<!DOCTYPE html>
<html lang="en">

<head>
    <title>MR RACER ULTIMATE â€” Vylex Nexys Edition (Desktop + Mobile)</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1, maximum-scale=1">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@400;600;700&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --cy: #00ffff;
            --cy-10: rgba(0, 255, 255, .1);
            --cy-20: rgba(0, 255, 255, .2);
            --cy-40: rgba(0, 255, 255, .4);
            --cy-50: rgba(0, 255, 255, .5);
            --bg1: #0c0c0c;
            --bg2: #1a1a2e;
            --bg3: #16213e;
            --hud-bg: rgba(0, 18, 32, .6);
            --hud-stroke: rgba(255, 255, 255, .15);
            --txt: #fff;
            --warn: #ff6400;
            --ok: #00ff88;
            --danger: #ff3b30;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
        }

        body {
            overflow: hidden;
            background: linear-gradient(135deg, var(--bg1) 0%, var(--bg2) 50%, var(--bg3) 100%);
            font-family: 'Rajdhani', sans-serif;
            color: var(--txt);
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        canvas#game-canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            filter: contrast(1.08) saturate(1.15);
        }

        /* HUD */
        #hud {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 100;
        }

        .hud-container {
            position: absolute;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .hud-top-left {
            top: 12px;
            left: 12px;
        }

        .hud-top-right {
            top: 12px;
            right: 12px;
            align-items: flex-end;
        }

        .hud-bottom-left {
            bottom: 12px;
            left: 12px;
        }

        .hud-bottom-right {
            bottom: 12px;
            right: 12px;
            align-items: flex-end;
        }

        .hud-box {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.12) 0%, rgba(0, 150, 255, 0.22) 100%);
            border: 1px solid var(--cy-50);
            border-radius: 12px;
            padding: 10px 14px;
            backdrop-filter: blur(10px);
            box-shadow: 0 6px 24px rgba(0, 255, 255, 0.08);
        }

        .hud-box .label {
            font-size: 11px;
            color: var(--cy);
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
        }

        .hud-box .value {
            font-family: 'Orbitron', monospace;
            font-size: 24px;
            font-weight: 800;
            color: var(--txt);
            text-shadow: 0 0 10px rgba(255, 255, 255, .35);
        }

        .hud-stats {
            background: var(--hud-bg);
            border: 1px solid var(--hud-stroke);
            border-radius: 10px;
            padding: 12px;
            display: grid;
            grid-template-columns: auto auto;
            gap: 6px 18px;
            backdrop-filter: blur(12px);
        }

        .hud-stats .label {
            font-size: 12px;
            color: var(--cy);
            text-transform: uppercase;
            letter-spacing: .5px;
            font-weight: 600;
        }

        .hud-stats .value {
            font-family: 'Orbitron', monospace;
            font-size: 15px;
            font-weight: 800;
            color: var(--txt);
            text-align: right;
        }

        .speedometer {
            width: 110px;
            height: 110px;
            border: 2px solid var(--cy);
            border-radius: 50%;
            background: radial-gradient(circle, rgba(0, 20, 40, 0.92) 0%, rgba(0, 10, 20, 0.96) 100%);
            position: relative;
            backdrop-filter: blur(10px);
        }

        .speedometer-needle {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 2px;
            height: 42px;
            background: linear-gradient(180deg, #ff0040 0%, var(--warn) 100%);
            transform-origin: bottom center;
            transform: translate(-50%, -100%) rotate(0deg);
            transition: transform 0.08s ease-out;
            box-shadow: 0 0 10px rgba(255, 0, 64, .7);
        }

        .speedometer-center {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 11px;
            height: 11px;
            background: var(--cy);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 14px rgba(0, 255, 255, .8);
        }

        .speedometer-text {
            position: absolute;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Orbitron', monospace;
            font-size: 13px;
            font-weight: 800;
            color: var(--cy);
        }

        .minimap {
            width: 140px;
            height: 180px;
            background: rgba(0, 20, 40, .9);
            border: 2px solid var(--cy);
            border-radius: 10px;
            position: relative;
            backdrop-filter: blur(10px);
            overflow: hidden;
        }

        .minimap-road {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            width: 42px;
            height: 100%;
            background: linear-gradient(180deg, #404040 0%, #5a5a5a 50%, #404040 100%);
        }

        .minimap-player {
            position: absolute;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            width: 8px;
            height: 12px;
            background: #ffff00;
            border-radius: 2px;
            box-shadow: 0 0 10px rgba(255, 255, 0, .8);
            transition: left .16s ease;
        }

        .minimap-traffic {
            position: absolute;
            width: 6px;
            height: 10px;
            background: #ff4444;
            border-radius: 1px;
            transition: top .1s linear, left .1s linear;
        }

        /* Overlay */
        #game-overlay {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, rgba(0, 0, 0, .9) 0%, rgba(10, 10, 30, .95) 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: center;
            z-index: 1000;
            backdrop-filter: blur(20px);
            padding: 20px;
        }

        #game-overlay h1 {
            font-family: 'Orbitron', monospace;
            font-size: 48px;
            font-weight: 900;
            margin: 0 0 12px;
            background: linear-gradient(135deg, var(--cy) 0%, #0080ff 50%, #ff00ff 100%);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 28px rgba(0, 255, 255, .5);
            animation: titlePulse 3s ease-in-out infinite;
        }

        #game-overlay .brand {
            font-family: Arial, sans-serif;
            font-size: 14px;
            color: #7ba87a;
        }

        #game-overlay .brand-name {
            font-family: Arial, sans-serif;
            font-size: 14px;
            animation: brandPulse 3s ease-in-out infinite;
            text-shadow: 0 0 10px currentColor;
        }

        @keyframes brandPulse {
            0% { color: #e24c4b; } 16.66% { color: #ff6b35; } 33.33% { color: #ffb347; } 50% { color: #ffd700; } 66.66% { color: #32cd32; } 83.33% { color: #1e90ff; } 100% { color: #e24c4b; }
        }

        @keyframes titlePulse {
            0%, 100% { transform: scale(1) } 50% { transform: scale(1.04) }
        }

        #game-overlay p {
            font-size: 16px;
            margin: 10px 0 18px;
            color: #d6d6d6;
            line-height: 1.6;
        }

        .overlay-controls {
            display: grid;
            gap: 10px;
            margin: 10px 0 18px;
            grid-template-columns: repeat(2, minmax(180px, 1fr));
            width: min(900px, 100%);
        }

        .toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            justify-content: center;
            background: rgba(255, 255, 255, .05);
            border: 1px solid rgba(255, 255, 255, .12);
            border-radius: 10px;
            padding: 10px;
            color: #eaeaea;
        }

        .toggle input {
            pointer-events: auto;
        }

        .overlay-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }

        .btn {
            pointer-events: auto;
            font-family: 'Orbitron', monospace;
            font-size: 16px;
            font-weight: 800;
            padding: 12px 20px;
            border: 2px solid var(--cy);
            background: linear-gradient(135deg, var(--cy-10) 0%, var(--cy-20) 100%);
            color: var(--cy);
            cursor: pointer;
            border-radius: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all .25s ease;
            backdrop-filter: blur(10px);
        }

        .btn:hover {
            background: linear-gradient(135deg, rgba(0, 255, 255, .25) 0%, rgba(0, 150, 255, .35) 100%);
            transform: translateY(-1px);
        }

        .btn.secondary {
            border-color: rgba(255, 255, 255, .25);
            color: #ddd;
        }

        /* Top bar actions */
        .top-actions {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            pointer-events: auto;
        }

        .icon-btn {
            width: 42px;
            height: 42px;
            border-radius: 10px;
            display: grid;
            place-items: center;
            background: rgba(0, 0, 0, .35);
            border: 1px solid rgba(255, 255, 255, .2);
            color: #fff;
            font-weight: 900;
            font-family: 'Orbitron', monospace;
            cursor: pointer;
        }

        .icon-btn:active {
            transform: translateY(1px) scale(.98);
        }

        /* Achievement feed */
        .achievement-feed {
            position: absolute;
            top: 12px;
            right: 12px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            width: min(54vw, 320px);
            pointer-events: none;
            z-index: 200;
        }

        .achievement-line {
            background: rgba(0, 0, 0, .4);
            color: #ffe083;
            border: 1px solid rgba(255, 208, 0, .35);
            border-radius: 8px;
            padding: 6px 10px;
            font-family: 'Orbitron', monospace;
            font-size: 12px;
            font-weight: 800;
            opacity: 0;
            transform: translateY(-8px);
            animation: ach-in .35s ease forwards, ach-out .4s ease 3.2s forwards;
            text-align: right;
        }

        @keyframes ach-in { to { opacity: 1; transform: translateY(0); } }
        @keyframes ach-out { to { opacity: 0; transform: translateY(-8px); } }

        /* Particles for weather (rain) */
        .particle-container {
            position: fixed; inset: 0; pointer-events: none; z-index: 50;
        }

        .particle {
            position: absolute;
            width: 2px; height: 10px;
            background: rgba(173, 216, 230, .8);
            border-radius: 1px;
            animation: particle-fall linear infinite;
        }

        @keyframes particle-fall {
            from { transform: translateY(-10vh); opacity: 0; }
            10% { opacity: 1; } 90% { opacity: 1; }
            to { transform: translateY(100vh); opacity: 0; }
        }

        /* === MOBILE CONTROLS FIX & IMPROVEMENT === */
        .touch-controls {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 150;
        }

        .pad {
            position: absolute;
            bottom: 10px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .pad.left {
            left: 10px;
        }

        .pad.right {
            right: 10px;
        }

        .ctrl-btn {
            pointer-events: auto;
            width: 64px;
            height: 64px;
            border-radius: 50%;
            display: grid;
            place-items: center;
            background: rgba(0, 0, 0, .45);
            border: 1px solid rgba(255, 255, 255, .2);
            color: #fff;
            font-weight: 900;
            font-size: 18px;
            font-family: 'Orbitron', monospace;
            touch-action: none;
            backdrop-filter: blur(5px);
        }
        .ctrl-btn:active {
            background: rgba(0,0,0,0.6);
            transform: scale(0.95);
        }

        .ctrl-btn.small {
            width: 54px;
            height: 54px;
        }

        .ctrl-btn.nitro {
            border-radius: 14px;
            width: 96px;
            height: 64px;
            color: #000;
            background: linear-gradient(135deg, rgba(255, 255, 255, .85) 0%, #ffdd55 100%);
            border-color: #ffd84a;
        }

        .mobile-only {
            display: none;
        }

        /* Nitro bar */
        .nitro-bar {
            width: 180px;
            height: 12px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, .2);
            background: rgba(0, 0, 0, .35);
            overflow: hidden;
            position: relative;
        }

        .nitro-fill {
            position: absolute; left: 0; top: 0; bottom: 0;
            width: 0%;
            background: linear-gradient(90deg, #36f, #0ff, #0f9);
        }

        @media (max-width: 900px) {
            #game-overlay h1 { font-size: 36px; }
            .hud-box .value { font-size: 20px; }
            .speedometer { width: 86px; height: 86px; }
            .minimap { width: 100px; height: 140px; }
            .top-actions { top: 8px; }
            .icon-btn { width: 40px; height: 40px; border-radius: 10px; }
            .mobile-only { display: block; }
        }

        @media (max-width: 600px) {
            .overlay-controls { grid-template-columns: 1fr; }
        }

        /* Responsive controls for small portrait screens */
        @media (max-width: 480px) and (orientation: portrait) {
            .ctrl-btn { width: 56px; height: 56px; }
            .ctrl-btn.small { width: 50px; height: 50px; }
            .ctrl-btn.nitro { width: 84px; height: 56px; }
            .pad { gap: 8px; }
        }
    </style>
</head>

<body>
    <div class="particle-container" id="particles"></div>

    <!-- HUD -->
    <div id="hud" aria-hidden="true">
        <div class="top-actions">
            <button id="btn-pause" class="icon-btn" title="Pause/Resume" aria-label="Pause">II</button>
            <button id="btn-mute" class="icon-btn" title="Mute/Unmute" aria-label="Mute">ðŸ”ˆ</button>
        </div>
        <div class="hud-container hud-top-left">
            <div class="hud-box">
                <div class="label">Score</div>
                <div class="value" id="score-val">0</div>
            </div>
            <div class="hud-box mobile-only">
                <div class="label">Nitro</div>
                <div class="nitro-bar">
                    <div class="nitro-fill" id="nitro-fill"></div>
                </div>
            </div>
        </div>
        <div class="hud-container hud-top-right">
            <div class="hud-stats">
                <div class="label">Level</div><div class="value" id="level-val">1</div>
                <div class="label">Gear</div><div class="value" id="gear-val">N</div>
                <div class="label">Distance</div><div class="value" id="distance-val">0.0 KM</div>
                <div class="label">Overtakes</div><div class="value" id="overtake-val">0</div>
                <div class="label">Best Combo</div><div class="value" id="best-combo-val">0</div>
                <div class="label">Accuracy</div><div class="value" id="accuracy-val">100%</div>
            </div>
        </div>
        <div class="hud-container hud-bottom-left">
            <div class="speedometer">
                <div class="speedometer-needle" id="speedometer-needle"></div>
                <div class="speedometer-center"></div>
                <div class="speedometer-text" id="speedometer-text">0</div>
            </div>
            <div class="hud-box desktop-only" style="margin-top:8px;">
                <div class="label">Nitro</div>
                <div class="nitro-bar" style="width:140px;"><div class="nitro-fill" id="nitro-fill-desktop"></div></div>
            </div>
        </div>
        <div class="hud-container hud-bottom-right">
            <div class="minimap">
                <div class="minimap-road"></div>
                <div class="minimap-player" id="minimap-player"></div>
            </div>
        </div>
        <div class="achievement-feed" id="achievement-feed" aria-live="polite"></div>
    </div>

    <!-- Touch Controls -->
    <div class="touch-controls" id="touch-controls" aria-hidden="false">
        <div class="pad">
            <button class="ctrl-btn small" data-control="left" aria-label="Left">â—€</button>
            <button class="ctrl-btn small" data-control="right" aria-label="Right">â–¶</button>
        </div>
        <div class="pad">
            <button class="ctrl-btn" data-control="down" aria-label="Brake">â–¼</button>
            <button class="ctrl-btn" data-control="up" aria-label="Accelerate">â–²</button>
            <button class="ctrl-btn nitro" data-control="nitro" aria-label="Nitro">NITRO</button>
        </div>
    </div>

    <!-- Overlay -->
    <div id="game-overlay">
        <h1>MR RACER ULTIMATE</h1>
        <p class="brand">Made by <span class="brand-name">Vylex Nexys</span> â€¢ Desktop & Mobile<br>
            Overtake traffic to build combos. Achievements appear as small text at the top â€” never blocking your view.
        </p>
        <p>Controls:<br>- Desktop: Arrow Keys to drive, Space = Nitro, P = Pause<br>- Mobile: On-screen buttons, optional Tilt steering</p>
        <div class="overlay-controls">
            <label class="toggle"><input type="checkbox" id="chk-tilt"> Enable Tilt Steering (mobile)</label>
            <label class="toggle"><input type="checkbox" id="chk-lefty"> Left-handed Controls</label>
            <label class="toggle"><input type="checkbox" id="chk-lowgfx"> Low Graphics Mode</label>
            <label class="toggle"><input type="checkbox" id="chk-autoperf" checked> Auto Performance Tuning</label>
        </div>
        <div class="overlay-buttons">
            <button class="btn" id="btn-start">Start Racing</button>
            <button class="btn secondary" id="btn-tilt-permission" style="display:none;">Enable Motion Access</button>
        </div>
        <p style="opacity:.8; font-size:14px; margin-top:8px;">Tip: Rotate your device to landscape for the best experience.</p>
    </div>

    <canvas id="game-canvas"></canvas>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>
    <script type="module">
        import * as THREE from 'three';

        // -------- Core State --------
        let scene, camera, renderer, playerCar, sun;
        let gameStarted = false, paused = false, gameOver = false;
        const keys = Object.create(null);
        const isTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
        const isSmall = () => window.innerWidth < 920;
        let quality = { low: false, autoPerf: true, muted: false };
        let tilt = { enabled: false, lastChange: 0, threshold: 6, cooldownMs: 250 };
        let lefty = false;

        // Gameplay
        let speed = 0, score = 0, distance = 0, overtakes = 0, combo = 0, bestCombo = 0, comboTimer = 0;
        let level = 1, accuracy = 100, crashes = 0, nitroBoost = 100, weather = 'clear', timeOfDay = 0;

        const MAX_SPEED = 1.35, ACCELERATION = 0.0075, BRAKE_POWER = 0.016, FRICTION = 0.0032, NITRO_POWER = 0.022;
        const LANE_WIDTH = 3.6;
        const LANES = [-LANE_WIDTH * 1.5, -LANE_WIDTH * 0.5, LANE_WIDTH * 0.5, LANE_WIDTH * 1.5];
        let currentLane = 1;

        // Objects
        const roadSegments = [], trafficCars = [], sceneryObjects = [], achievements = [], pointLights = [];
        const roadSegmentLength = 52;

        // Audio
        let audioContext = null;
        const sounds = {};
        function ensureAudio() {
            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    initSounds();
                } catch (e) { console.error("Could not create AudioContext", e); }
            }
        }

        // HUD refs
        const scoreVal = document.getElementById('score-val'), levelVal = document.getElementById('level-val'), gearVal = document.getElementById('gear-val'), distanceVal = document.getElementById('distance-val'), overtakeVal = document.getElementById('overtake-val'), bestComboVal = document.getElementById('best-combo-val'), accuracyVal = document.getElementById('accuracy-val'), speedometerNeedle = document.getElementById('speedometer-needle'), speedometerText = document.getElementById('speedometer-text'), minimapPlayer = document.getElementById('minimap-player'), achievementFeed = document.getElementById('achievement-feed'), nitroFillMobile = document.getElementById('nitro-fill'), nitroFillDesktop = document.getElementById('nitro-fill-desktop');

        // UI refs
        const overlay = document.getElementById('game-overlay'), btnStart = document.getElementById('btn-start'), btnTiltPerm = document.getElementById('btn-tilt-permission'), chkTilt = document.getElementById('chk-tilt'), chkLefty = document.getElementById('chk-lefty'), chkLowGfx = document.getElementById('chk-lowgfx'), chkAutoPerf = document.getElementById('chk-autoperf'), btnPause = document.getElementById('btn-pause'), btnMute = document.getElementById('btn-mute'), touchControls = document.getElementById('touch-controls'), particlesLayer = document.getElementById('particles');

        // Performance tuning
        let frameCount = 0, lastPerfCheck = performance.now();
        let targetPixelRatio = Math.min(window.devicePixelRatio, 2);
        let miniMapUpdateTimer = 0, minimapDots = [];

        const save = (k, v) => localStorage.setItem(k, JSON.stringify(v));
        const load = (k, d) => { try { return JSON.parse(localStorage.getItem(k)) ?? d; } catch { return d; } };

        // -------- Init --------
        function init() {
            quality.low = load('mr.lowgfx', false);
            quality.autoPerf = load('mr.autoperf', true);
            lefty = load('mr.lefty', false);
            tilt.enabled = load('mr.tilt', false);
            quality.muted = load('mr.muted', false);

            chkLowGfx.checked = quality.low;
            chkAutoPerf.checked = quality.autoPerf;
            chkLefty.checked = lefty;
            chkTilt.checked = tilt.enabled;
            btnMute.textContent = quality.muted ? 'ðŸ”‡' : 'ðŸ”ˆ';

            scene = new THREE.Scene();
            updateEnvironment(true);

            camera = new THREE.PerspectiveCamera(74, window.innerWidth / window.innerHeight, 0.1, 240);
            camera.position.set(0, 4.2, 6.4);
            camera.rotation.x = -0.12;

            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('game-canvas'), antialias: true, powerPreference: 'high-performance', alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(targetPixelRatio);
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            applyGraphicsQuality(); // Apply initial quality settings

            createLights();
            createPlayerCar();
            createRoad();
            createScenery();
            createTraffic(isTouch || isSmall() ? 12 : 18);
            createWeatherParticles();
            createMinimapDots();
            setupInputs();

            if (isTouch && typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                btnTiltPerm.style.display = 'inline-block';
            }

            window.addEventListener('resize', onResize);
            btnStart.addEventListener('click', startGame);
            btnTiltPerm.addEventListener('click', requestMotionPermission);
            btnPause.addEventListener('click', togglePause);
            btnMute.addEventListener('click', toggleMute);
            chkLowGfx.addEventListener('change', () => { quality.low = chkLowGfx.checked; save('mr.lowgfx', quality.low); applyGraphicsQuality(); });
            chkAutoPerf.addEventListener('change', () => { quality.autoPerf = chkAutoPerf.checked; save('mr.autoperf', quality.autoPerf); });
            chkLefty.addEventListener('change', () => { lefty = chkLefty.checked; save('mr.lefty', lefty); layoutTouchControls(); });
            chkTilt.addEventListener('change', () => { tilt.enabled = chkTilt.checked; save('mr.tilt', tilt.enabled); });

            layoutTouchControls();
        }

        function startGame() {
            gameStarted = true; paused = false; gameOver = false;
            overlay.style.display = 'none';
            resetGame();
            ensureAudio();
            animate();
        }
        
        // ... (The rest of your JS code follows)
        // Note: The following JS needs to be placed inside the <script type="module"> tag. 
        // I will provide the complete, corrected JS part.
        
        function resetGame() {
            speed = 0; score = 0; distance = 0;
            overtakes = 0; combo = 0; bestCombo = 0; comboTimer = 0;
            level = 1; accuracy = 100; crashes = 0; nitroBoost = 100;
            currentLane = 1; timeOfDay = Math.random(); weather = Math.random() > 0.78 ? 'rain' : 'clear';
            achievements.length = 0; // Clear achievements for new game

            playerCar.position.set(LANES[currentLane], 0.42, 0);
            playerCar.rotation.set(0, 0, 0);

            trafficCars.forEach(car => resetTrafficCar(car, true));
            updateEnvironment(true);
            updateWeatherParticles();
        }

        function createLights() {
            scene.add(new THREE.AmbientLight(0x404040, 0.48));
            sun = new THREE.DirectionalLight(0xffffff, 0.95);
            sun.position.set(60, 70, 35);
            sun.shadow.mapSize.set(1024, 1024);
            sun.shadow.camera.near = 0.5; sun.shadow.camera.far = 260;
            sun.shadow.camera.left = -60; sun.shadow.camera.right = 60;
            sun.shadow.camera.top = 60; sun.shadow.camera.bottom = -60;
            scene.add(sun);
            
            for (let i = 0; i < 10; i++) {
                const lamp = new THREE.PointLight(0xffa500, 0.35, 20);
                lamp.position.set((i % 2 ? -1 : 1) * 8.8, 6.2, -i * 30);
                scene.add(lamp);
                pointLights.push(lamp);
            }
        }

        function updateEnvironment(force = false) {
            const skyDay = new THREE.Color(0x87CEEB), skySun = new THREE.Color(0xFF7F50), skyNight = new THREE.Color(0x0d1030);
            let col = (timeOfDay < 0.33) ? skyDay : (timeOfDay < 0.66) ? skySun : skyNight;
            if (force) { scene.background = col; scene.fog = new THREE.Fog(col, 22, 140); } 
            else { scene.background.lerp(col, 0.02); scene.fog.color.lerp(col, 0.02); }
        }

        function createPlayerCar() {
            const g = new THREE.Group();
            g.add(new THREE.Mesh(new THREE.BoxGeometry(1.85, 0.8, 3.9), new THREE.MeshStandardMaterial({ color: 0x00ff88, metalness: 0.85, roughness: 0.28 })));
            const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.7, 2.3), new THREE.MeshStandardMaterial({ color: 0x222831, metalness: 0.1, roughness: 0.1, transparent: true, opacity: 0.78 }));
            cabin.position.set(0, 0.76, -0.1); g.add(cabin);
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: .6 });
            const wGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.18, 10);
            [[-0.8, -0.2, 1.15], [0.8, -0.2, 1.15], [-0.8, -0.2, -1.15], [0.8, -0.2, -1.15]].forEach(p => {
                const w = new THREE.Mesh(wGeo, wheelMat); w.position.set(...p); w.rotation.z = Math.PI / 2; g.add(w);
            });
            const headGeo = new THREE.SphereGeometry(0.14, 8, 8);
            const headMat = new THREE.MeshBasicMaterial({ color: 0xffffaa });
            [[-0.58, .22, 1.8], [0.58, .22, 1.8]].forEach(p => {
                const m = new THREE.Mesh(headGeo, headMat); m.position.set(...p); g.add(m);
                const L = new THREE.PointLight(0xffffaa, 0.55, 14); L.position.copy(m.position); g.add(L);
            });
            g.position.y = 0.42; playerCar = g; scene.add(g);
        }

        function createRoad() {
            const roadMat = new THREE.MeshStandardMaterial({ color: 0x3e3e3e, roughness: 0.86, metalness: 0.08 });
            const roadGeo = new THREE.PlaneGeometry(LANE_WIDTH * 4 + 8, roadSegmentLength);
            const grassGeo = new THREE.PlaneGeometry(220, roadSegmentLength);
            const grassColors = [0x255b2b, 0x2e6b30, 0x3b7f3c];
            const markMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const markGeo = new THREE.PlaneGeometry(0.16, 4.2); // Smaller segments for dashed line effect
            
            for (let i = 0; i < 6; i++) {
                const segmentGroup = new THREE.Group();
                const road = new THREE.Mesh(roadGeo, roadMat);
                road.rotation.x = -Math.PI / 2;
                road.receiveShadow = true;
                segmentGroup.add(road);

                for (let j = -1; j <= 1; j++) {
                    for (let k = 0; k < 6; k++) { // 6 dashes per road segment
                        const m = new THREE.Mesh(markGeo, markMat);
                        m.rotation.x = -Math.PI / 2;
                        m.position.set(j * LANE_WIDTH, 0.011, (k - 2.5) * (roadSegmentLength / 6));
                        segmentGroup.add(m);
                    }
                }
                
                [-110, 110].forEach(x => {
                    const grassMat = new THREE.MeshStandardMaterial({ color: grassColors[i % grassColors.length], roughness: 1 });
                    const grass = new THREE.Mesh(grassGeo, grassMat);
                    grass.rotation.x = -Math.PI / 2;
                    grass.position.set(x, -0.02, 0);
                    grass.receiveShadow = true;
                    segmentGroup.add(grass);
                });

                segmentGroup.position.z = -i * roadSegmentLength;
                roadSegments.push(segmentGroup);
                scene.add(segmentGroup);
            }
        }
        
        function createScenery() {
            const createTree = (type = 'pine') => {
                const group = new THREE.Group();
                if (type === 'pine') {
                    const cone = new THREE.Mesh(new THREE.ConeGeometry(1 + Math.random(), 3.6 + Math.random() * 1.6, 8), new THREE.MeshStandardMaterial({ color: 0x1f7a1f }));
                    cone.position.y = 2.8; group.add(cone);
                } else {
                    const sph = new THREE.Mesh(new THREE.SphereGeometry(1.4 + Math.random() * 0.8, 8, 6), new THREE.MeshStandardMaterial({ color: 0x32cd32 }));
                    sph.position.y = 3.1; group.add(sph);
                }
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(.2, .3, 1.8 + Math.random() * 0.6), new THREE.MeshStandardMaterial({ color: 0x8b5a2b }));
                trunk.position.y = .9; group.add(trunk);
                return group;
            };

            const createBuilding = () => {
                const grp = new THREE.Group();
                const h = 6 + Math.random() * 13, w = 2 + Math.random() * 3, d = 2 + Math.random() * 3;
                const mat = new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL(Math.random(), .28, .5) });
                const box = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
                box.position.y = h / 2; grp.add(box);
                return grp;
            };

            for (let i = 0; i < 42; i++) {
                const x = (Math.random() > 0.5 ? 1 : -1) * (LANE_WIDTH * 2.5 + 6 + Math.random() * 22);
                const z = -Math.random() * 340;
                let obj;
                if (Math.abs(x) > 15) {
                    obj = (Math.random() > 0.68) ? createBuilding() : createTree(Math.random() > 0.6 ? 'pine' : 'oak');
                } else { obj = createTree(); }
                obj.position.set(x, 0, z);
                sceneryObjects.push(obj); scene.add(obj);
            }
        }

        function createTraffic(count = 16) {
            const types = [ { size: [1.8, 1.2, 4] }, { size: [2.2, 1.7, 4.4] }, { size: [2.6, 2.6, 8], color: 0xcccccc }, { size: [1.6, 1.0, 3.7] }, { size: [1.7, 1.25, 3.6] } ];
            const colors = [0xff3b30, 0x007aff, 0xffffff, 0x000000, 0x8e44ad, 0x2ecc71, 0xff9500, 0x00d1ff];
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const wGeo = new THREE.CylinderGeometry(0.25, 0.25, 0.15, 8);

            for (let i = 0; i < count; i++) {
                const t = types[Math.floor(Math.random() * types.length)];
                const g = new THREE.Group();
                const color = t.color ?? colors[Math.floor(Math.random() * colors.length)];
                g.add(new THREE.Mesh(new THREE.BoxGeometry(...t.size), new THREE.MeshStandardMaterial({ color, metalness: .6, roughness: .45 })));
                
                const wheelCount = t.size[2] > 6 ? 6 : 4;
                const spacing = t.size[2] / (wheelCount === 6 ? 3 : 2);
                for (let j = 0; j < wheelCount / 2; j++) {
                    [-t.size[0] * 0.4, t.size[0] * 0.4].forEach(x => {
                        const w = new THREE.Mesh(wGeo, wheelMat);
                        w.position.set(x, -t.size[1] * 0.4, t.size[2] * 0.4 - j * spacing);
                        w.rotation.z = Math.PI / 2; g.add(w);
                    });
                }
                g.position.y = t.size[1] / 2;
                scene.add(g); trafficCars.push(g);
            }
            trafficCars.forEach(c => resetTrafficCar(c, true));
        }

        function resetTrafficCar(car, initial = false) {
            car.userData.speed = (Math.random() * 0.22 + 0.10) * (1 + level * 0.02);
            car.userData.overtaken = false;
            car.userData.targetX = undefined;
            car.position.x = LANES[Math.floor(Math.random() * LANES.length)];
            car.position.z = initial ? -Math.random() * 260 - 40 : -200 - Math.random() * 140;
        }

        function createWeatherParticles() {
            for (let i = 0; i < 120; i++) {
                const p = document.createElement('div');
                p.className = 'particle';
                p.style.left = `${Math.random()*100}%`; p.style.animationDelay = `${Math.random()*2}s`; p.style.animationDuration = `${Math.random()*2+2.4}s`;
                particlesLayer.appendChild(p);
            }
            updateWeatherParticles();
        }

        function updateWeatherParticles() {
            particlesLayer.style.display = (weather === 'rain') ? 'block' : 'none';
        }

        function createMinimapDots() {
            const minimap = document.querySelector('.minimap');
            for (let i = 0; i < trafficCars.length; i++) {
                const dot = document.createElement('div');
                dot.className = 'minimap-traffic';
                dot.style.display = 'none';
                minimap.appendChild(dot);
                minimapDots.push(dot);
            }
        }

        function initSounds() {
            sounds.overtake = () => beep(440, 0.08, 0.06); sounds.lane = () => beep(270, 0.05, 0.05);
            sounds.nitro = () => beep(880, 0.16, 0.09); sounds.crash = () => noise(0.26, 0.08);
            sounds.ach = () => { beep(523, .08, .06); setTimeout(() => beep(659, .08, .06), 90); setTimeout(() => beep(784, .16, .08), 180); }
        }
        function beep(freq, dur, vol = 0.08) { if (!audioContext || quality.muted) return; const o = audioContext.createOscillator(), g = audioContext.createGain(); o.connect(g); g.connect(audioContext.destination); o.frequency.value = freq; o.type = 'square'; g.gain.setValueAtTime(vol, audioContext.currentTime); g.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + dur); o.start(); o.stop(audioContext.currentTime + dur); }
        function noise(dur = 0.2, vol = 0.08) { if (!audioContext || quality.muted) return; const size = audioContext.sampleRate * dur, buffer = audioContext.createBuffer(1, size, audioContext.sampleRate), data = buffer.getChannelData(0); for (let i = 0; i < size; i++) data[i] = Math.random() * 2 - 1; const src = audioContext.createBufferSource(); src.buffer = buffer; const g = audioContext.createGain(); g.gain.value = vol; src.connect(g); g.connect(audioContext.destination); src.start(); setTimeout(() => src.stop(), dur * 1000); }
        function playSound(name) { try { ensureAudio(); sounds[name] && sounds[name](); } catch {} }
        function toggleMute() { quality.muted = !quality.muted; btnMute.textContent = quality.muted ? 'ðŸ”‡' : 'ðŸ”ˆ'; save('mr.muted', quality.muted); }
        
        function setupInputs() {
            window.addEventListener('keydown', e => { keys[e.code] = true; if (e.code === 'KeyP') togglePause(); if (!gameStarted || gameOver) return; if (e.code === 'ArrowLeft' && !keys['_left_once']) { laneLeft(); keys['_left_once'] = true; playSound('lane'); } if (e.code === 'ArrowRight' && !keys['_right_once']) { laneRight(); keys['_right_once'] = true; playSound('lane'); } if (e.code === 'Space') { keys['nitro'] = true; playSound('nitro'); } });
            window.addEventListener('keyup', e => { keys[e.code] = false; if (e.code === 'ArrowLeft') keys['_left_once'] = false; if (e.code === 'ArrowRight') keys['_right_once'] = false; if (e.code === 'Space') keys['nitro'] = false; });
            touchControls.querySelectorAll('.ctrl-btn').forEach(btn => {
                const ctl = btn.getAttribute('data-control');
                const on = (v) => { if (ctl === 'left' && v) { laneLeft(); playSound('lane'); } else if (ctl === 'right' && v) { laneRight(); playSound('lane'); } else if (ctl === 'up') keys['ArrowUp'] = v; else if (ctl === 'down') keys['ArrowDown'] = v; else if (ctl === 'nitro') { keys['nitro'] = v; if (v) playSound('nitro'); } };
                btn.addEventListener('pointerdown', e => { e.preventDefault(); on(true); btn.setPointerCapture(e.pointerId); });
                btn.addEventListener('pointerup', () => on(false)); btn.addEventListener('pointercancel', () => on(false)); btn.addEventListener('pointerleave', () => on(false));
            });
            let touchStart = null;
            window.addEventListener('touchstart', e => { if (!e.target.closest('.ctrl-btn')) touchStart = { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY }; }, { passive: true });
            window.addEventListener('touchend', e => { if (!touchStart) return; const dx = e.changedTouches[0].clientX - touchStart.x, dy = e.changedTouches[0].clientY - touchStart.y, adx = Math.abs(dx), ady = Math.abs(dy); if (Math.max(adx, ady) > 24) { if (adx > ady) { dx < 0 ? laneLeft() : laneRight(); playSound('lane'); } else { dy < 0 ? keys['ArrowUp'] = true : keys['ArrowDown'] = true; setTimeout(() => { keys['ArrowUp'] = false; keys['ArrowDown'] = false; }, 180); } } touchStart = null; });
            window.addEventListener('deviceorientation', e => { if (!tilt.enabled || !gameStarted || paused || gameOver) return; const gamma = e.gamma, now = performance.now(); if (gamma < -tilt.threshold && now - tilt.lastChange > tilt.cooldownMs) { laneLeft(); playSound('lane'); tilt.lastChange = now; } else if (gamma > tilt.threshold && now - tilt.lastChange > tilt.cooldownMs) { laneRight(); playSound('lane'); tilt.lastChange = now; } });
        }

        async function requestMotionPermission() { try { if (typeof DeviceMotionEvent.requestPermission === 'function') { const res = await DeviceMotionEvent.requestPermission(); showToast(res === 'granted' ? 'Motion access granted' : 'Motion access denied'); if (res === 'granted') btnTiltPerm.style.display = 'none'; } } catch {} }
        function laneLeft() { currentLane = Math.max(0, currentLane - 1); }
        function laneRight() { currentLane = Math.min(LANES.length - 1, currentLane + 1); }

        function togglePause() { if (!gameStarted || gameOver) return; paused = !paused; overlay.style.display = paused ? 'flex' : 'none'; overlay.querySelector('h1').textContent = paused ? 'Paused' : 'MR RACER ULTIMATE'; overlay.querySelector('p').innerHTML = paused ? 'Game paused. Tap Resume to continue.' : 'Experience the ultimate racing challenge!'; btnStart.textContent = paused ? 'Resume' : 'Start Racing'; }

        function animate() { if (!gameStarted) return; requestAnimationFrame(animate); if (paused || gameOver) return; handleInput(); updateState(); checkCollisions(); updateHUD(); maybeUpdateMinimap(); renderer.render(scene, camera); if (quality.autoPerf) { frameCount++; const now = performance.now(); if (now - lastPerfCheck > 1600) { adaptPerformance(frameCount * 1000 / (now - lastPerfCheck)); frameCount = 0; lastPerfCheck = now; } } }
        function handleInput() { if (keys['ArrowUp']) speed = Math.min(MAX_SPEED, speed + ACCELERATION); else if (keys['ArrowDown']) speed = Math.max(0, speed - BRAKE_POWER); else speed = Math.max(0, speed - FRICTION); if (keys['nitro'] && nitroBoost > 0) { speed = Math.min(MAX_SPEED * 1.55, speed + NITRO_POWER); nitroBoost = Math.max(0, nitroBoost - 0.6); } else if (nitroBoost < 100) { nitroBoost = Math.min(100, nitroBoost + 0.12); } }

        function updateState() {
            const targetX = LANES[currentLane];
            playerCar.position.x = THREE.MathUtils.lerp(playerCar.position.x, targetX, 0.16);
            playerCar.rotation.z = THREE.MathUtils.lerp(playerCar.rotation.z, (targetX - playerCar.position.x) * 0.22, 0.1);
            camera.position.z = playerCar.position.z + 6.2 + speed * 2.1;
            camera.position.y = 4.2 + speed * 1.4;
            camera.position.x = THREE.MathUtils.lerp(camera.position.x, playerCar.position.x * 0.28, 0.12);
            timeOfDay = (timeOfDay + 0.00046) % 1; updateEnvironment(false);
            roadSegments.forEach(r => { r.position.z += speed; if (r.position.z > roadSegmentLength) r.position.z -= roadSegments.length * roadSegmentLength; });
            sceneryObjects.forEach(o => { o.position.z += speed; if (o.position.z > camera.position.z + 24) o.position.z = -340 - Math.random() * 80; });
            trafficCars.forEach(car => {
                car.position.z += speed - car.userData.speed;
                if (Math.random() < 0.0012) { const newLane = THREE.MathUtils.clamp(nearestLaneIndex(car.position.x) + (Math.random() > 0.5 ? 1 : -1), 0, LANES.length - 1); car.userData.targetX = LANES[newLane]; }
                if (car.userData.targetX !== undefined) car.position.x = THREE.MathUtils.lerp(car.position.x, car.userData.targetX, 0.02);
                if (!car.userData.overtaken && car.position.z > camera.position.z + 6) handleOvertake(car);
                if (car.position.z > camera.position.z + 28) resetTrafficCar(car, false);
            });
            if (comboTimer > 0) { comboTimer -= 1 / 60; } else if (combo > 0) { combo = 0; }
            const newLevel = Math.floor(distance / 5) + 1;
            if (newLevel > level) { level = newLevel; pushAchievement(`Level ${level} reached`); trafficCars.forEach(c => c.userData.speed *= 1.04); }
            const kph = Math.floor(speed * 210); distance += (kph / 3600) / 60; score += Math.floor(kph / 12) + level; checkAchievements(kph);
        }

        function handleOvertake(car) { const pts = 100 * (combo + 1) * level; score += pts; overtakes++; combo++; bestCombo = Math.max(bestCombo, combo); comboTimer = 3.2; car.userData.overtaken = true; playSound('overtake'); floatPoint(`+${pts}`, '#00ff88'); }
        function checkAchievements(kph) {
            if (kph > 160 && !achievements.includes('spd160')) { achievements.push('spd160'); pushAchievement('Speed Demon: 160+ KPH'); }
            if (combo >= 10 && !achievements.includes('combo10')) { achievements.push('combo10'); pushAchievement('Combo Master: x10'); }
            if (distance > 25 && !achievements.includes('dist25')) { achievements.push('dist25'); pushAchievement('Traveller: 25 KM'); }
            if (distance > 50 && !achievements.includes('dist50')) { achievements.push('dist50'); pushAchievement('Long Hauler: 50 KM'); }
            if (overtakes >= 50 && !achievements.includes('ov50')) { achievements.push('ov50'); pushAchievement('Overtake Pro: 50'); }
            if (overtakes >= 100 && !achievements.includes('ov100')) { achievements.push('ov100'); pushAchievement('Overtake Champion: 100'); }
        }

        function checkCollisions() {
            const playerBox = new THREE.Box3().setFromObject(playerCar);
            for (const car of trafficCars) {
                if (Math.abs(car.position.z - playerCar.position.z) < 5) {
                    const trafficBox = new THREE.Box3().setFromObject(car);
                    if (playerBox.intersectsBox(trafficBox)) { onCrash(); break; }
                }
            }
        }

        function onCrash() { crashes++; accuracy = Math.max(0, Math.floor((overtakes / Math.max(1, overtakes + crashes)) * 100)); playSound('crash'); if (navigator.vibrate) navigator.vibrate(120); endGame(); }
        function endGame() { gameOver = true; paused = false; overlay.style.display = 'flex'; overlay.querySelector('h1').textContent = 'Race Complete'; overlay.querySelector('p').innerHTML = `<strong>Final Stats</strong><br>Score: ${score.toLocaleString()}<br>Level: ${level}<br>Distance: ${distance.toFixed(1)} KM<br>Overtakes: ${overtakes}<br>Best Combo: ${bestCombo}<br>Accuracy: ${accuracy}%<br>${saveBest()}`; btnStart.textContent = 'Race Again'; pushAchievement('Race Complete!'); }
        function saveBest() { const best = load('mr.best', { score: 0, dist: 0, combo: 0 }); let improved = []; if (score > best.score) { best.score = score; improved.push('Best score!'); } if (distance > best.dist) { best.dist = distance; improved.push('Best distance!'); } if (bestCombo > best.combo) { best.combo = bestCombo; improved.push('Best combo!'); } save('mr.best', best); return improved.length ? `<br><span style="color:${'var(--ok)'}">${improved.join(' ')}</span>` : ''; }

        function updateHUD() {
            scoreVal.textContent = score.toLocaleString(); levelVal.textContent = level; distanceVal.textContent = `${distance.toFixed(1)} KM`; overtakeVal.textContent = overtakes; bestComboVal.textContent = bestCombo; accuracyVal.textContent = `${accuracy}%`;
            const kph = Math.floor(speed * 210);
            speedometerText.textContent = kph;
            speedometerNeedle.style.transform = `translate(-50%, -100%) rotate(${(kph / 210) * 180 - 90}deg)`;
            gearVal.textContent = kph < 1 ? 'N' : kph < 25 ? '1' : kph < 50 ? '2' : kph < 80 ? '3' : kph < 110 ? '4' : kph < 140 ? '5' : '6';
            const nitroPct = `${Math.max(0, Math.min(100, nitroBoost))}%`;
            nitroFillMobile.style.width = nitroPct; nitroFillDesktop.style.width = nitroPct;
        }

        function maybeUpdateMinimap() {
            miniMapUpdateTimer++; if (miniMapUpdateTimer % 3 !== 0) return;
            minimapPlayer.style.left = `${20 + (currentLane / (LANES.length - 1)) * 60}%`;
            let dotIndex = 0;
            for (const car of trafficCars) {
                const relZ = car.position.z - camera.position.z;
                if (relZ > -90 && relZ < 26 && dotIndex < minimapDots.length) {
                    const dot = minimapDots[dotIndex];
                    const carLanePercent = (nearestLaneIndex(car.position.x) / (LANES.length - 1)) * 100;
                    dot.style.left = `${20 + carLanePercent * 0.6}%`;
                    dot.style.top = `${100 - ((relZ + 90) / 116) * 100}%`;
                    dot.style.display = 'block';
                    dotIndex++;
                }
            }
            for (let i = dotIndex; i < minimapDots.length; i++) { minimapDots[i].style.display = 'none'; }
        }

        function pushAchievement(text) {
            const line = document.createElement('div'); line.className = 'achievement-line'; line.textContent = text;
            achievementFeed.appendChild(line); if (achievementFeed.children.length > 4) achievementFeed.firstElementChild.remove();
            playSound('ach');
        }

        function floatPoint(text, color = '#00ff00') {
            const el = document.createElement('div');
            el.style.cssText = `position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);color:${color};font-size:22px;font-weight:800;text-shadow:0 0 8px rgba(0,0,0,.6);pointer-events:none;z-index:999;animation:fade-up .9s ease-out forwards;`;
            el.textContent = text; document.body.appendChild(el); setTimeout(() => el.remove(), 900);
        }
        (() => { const st = document.createElement('style'); st.textContent = `@keyframes fade-up { 0% { opacity: 1; transform: translate(-50%, -50%); } 100% { opacity: 0; transform: translate(-50%, -150%); } }`; document.head.appendChild(st); })();

        function nearestLaneIndex(x) { let best = 0, bestD = Infinity; for (let i = 0; i < LANES.length; i++) { const d = Math.abs(LANES[i] - x); if (d < bestD) { bestD = d; best = i; } } return best; }
        
        function onResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); if (quality.autoPerf) { targetPixelRatio = Math.min(window.devicePixelRatio, 2); renderer.setPixelRatio(targetPixelRatio); } layoutTouchControls(); }
        function layoutTouchControls() {
            if (!isTouch) { touchControls.style.display = 'none'; return; }
            touchControls.style.display = 'block';
            const pads = touchControls.querySelectorAll('.pad');
            pads.forEach(p => p.classList.remove('left', 'right'));
            const [leftControlsPad, rightControlsPad] = pads;
            if (lefty) { leftControlsPad.classList.add('right'); rightControlsPad.classList.add('left'); } 
            else { leftControlsPad.classList.add('left'); rightControlsPad.classList.add('right'); }
        }
        
        function applyGraphicsQuality() {
            renderer.antialias = !quality.low;
            renderer.shadowMap.enabled = !quality.low;
            renderer.toneMappingExposure = quality.low ? 1.0 : 1.15;
            const pr = quality.low ? Math.min(window.devicePixelRatio, 1.25) : targetPixelRatio;
            renderer.setPixelRatio(pr);
            if(sun) sun.castShadow = !quality.low;
            if(pointLights) pointLights.forEach(light => light.visible = !quality.low);
            const setShadows = (obj) => obj.traverse(child => { if(child.isMesh) child.castShadow = !quality.low; });
            if(playerCar) setShadows(playerCar);
            if(trafficCars) trafficCars.forEach(setShadows);
            if(sceneryObjects) sceneryObjects.forEach(setShadows);
        }

        function adaptPerformance(fps) {
            const pr = renderer.getPixelRatio();
            if (fps < 45 && pr > 0.9) renderer.setPixelRatio(Math.max(0.75, pr - 0.15));
            else if (fps > 65 && pr < targetPixelRatio) renderer.setPixelRatio(Math.min(targetPixelRatio, pr + 0.1));
        }
        
        init();
    </script>
</body>

</html>
