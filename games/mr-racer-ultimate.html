<!DOCTYPE html>
<html lang="en">

<head>
    <title>MR RACER ULTIMATE â€” Vylex Nexys Edition (Desktop + Mobile)</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1, maximum-scale=1">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@400;600;700&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --cy: #00ffff;
            --cy-10: rgba(0, 255, 255, .1);
            --cy-20: rgba(0, 255, 255, .2);
            --cy-40: rgba(0, 255, 255, .4);
            --cy-50: rgba(0, 255, 255, .5);
            --bg1: #0c0c0c;
            --bg2: #1a1a2e;
            --bg3: #16213e;
            --hud-bg: rgba(0, 18, 32, .6);
            --hud-stroke: rgba(255, 255, 255, .15);
            --txt: #fff;
            --warn: #ff6400;
            --ok: #00ff88;
            --danger: #ff3b30;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
        }

        body {
            overflow: hidden;
            background: linear-gradient(135deg, var(--bg1) 0%, var(--bg2) 50%, var(--bg3) 100%);
            font-family: 'Rajdhani', sans-serif;
            color: var(--txt);
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        canvas#game-canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            filter: contrast(1.08) saturate(1.15);
        }

        /* HUD */
        #hud {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 100;
        }

        .hud-container {
            position: absolute;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .hud-top-left {
            top: 12px;
            left: 12px;
        }

        .hud-top-right {
            top: 12px;
            right: 12px;
            align-items: flex-end;
        }

        .hud-bottom-left {
            bottom: 12px;
            left: 12px;
        }

        .hud-bottom-right {
            bottom: 12px;
            right: 12px;
            align-items: flex-end;
        }

        .hud-box {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.12) 0%, rgba(0, 150, 255, 0.22) 100%);
            border: 1px solid var(--cy-50);
            border-radius: 12px;
            padding: 10px 14px;
            backdrop-filter: blur(10px);
            box-shadow: 0 6px 24px rgba(0, 255, 255, 0.08);
        }

        .hud-box .label {
            font-size: 11px;
            color: var(--cy);
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
        }

        .hud-box .value {
            font-family: 'Orbitron', monospace;
            font-size: 24px;
            font-weight: 800;
            color: var(--txt);
            text-shadow: 0 0 10px rgba(255, 255, 255, .35);
        }

        .hud-stats {
            background: var(--hud-bg);
            border: 1px solid var(--hud-stroke);
            border-radius: 10px;
            padding: 12px;
            display: grid;
            grid-template-columns: auto auto;
            gap: 6px 18px;
            backdrop-filter: blur(12px);
        }

        .hud-stats .label {
            font-size: 12px;
            color: var(--cy);
            text-transform: uppercase;
            letter-spacing: .5px;
            font-weight: 600;
        }

        .hud-stats .value {
            font-family: 'Orbitron', monospace;
            font-size: 15px;
            font-weight: 800;
            color: var(--txt);
            text-align: right;
        }

        .speedometer {
            width: 110px;
            height: 110px;
            border: 2px solid var(--cy);
            border-radius: 50%;
            background: radial-gradient(circle, rgba(0, 20, 40, 0.92) 0%, rgba(0, 10, 20, 0.96) 100%);
            position: relative;
            backdrop-filter: blur(10px);
        }

        .speedometer-needle {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 2px;
            height: 42px;
            background: linear-gradient(180deg, #ff0040 0%, var(--warn) 100%);
            transform-origin: bottom center;
            transform: translate(-50%, -100%) rotate(0deg);
            transition: transform 0.08s ease-out;
            box-shadow: 0 0 10px rgba(255, 0, 64, .7);
        }

        .speedometer-center {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 11px;
            height: 11px;
            background: var(--cy);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 14px rgba(0, 255, 255, .8);
        }

        .speedometer-text {
            position: absolute;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Orbitron', monospace;
            font-size: 13px;
            font-weight: 800;
            color: var(--cy);
        }

        .minimap {
            width: 140px;
            height: 180px;
            background: rgba(0, 20, 40, .9);
            border: 2px solid var(--cy);
            border-radius: 10px;
            position: relative;
            backdrop-filter: blur(10px);
            overflow: hidden;
        }

        .minimap-road {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            width: 42px;
            height: 100%;
            background: linear-gradient(180deg, #404040 0%, #5a5a5a 50%, #404040 100%);
        }

        .minimap-player {
            position: absolute;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            width: 8px;
            height: 12px;
            background: #ffff00;
            border-radius: 2px;
            box-shadow: 0 0 10px rgba(255, 255, 0, .8);
            transition: left .16s ease;
        }

        .minimap-traffic {
            position: absolute;
            width: 6px;
            height: 10px;
            background: #ff4444;
            border-radius: 1px;
            transition: top .1s linear;
        }

        /* Overlay */
        #game-overlay {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, rgba(0, 0, 0, .9) 0%, rgba(10, 10, 30, .95) 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: center;
            z-index: 1000;
            backdrop-filter: blur(20px);
            padding: 20px;
        }

        #game-overlay h1 {
            font-family: 'Orbitron', monospace;
            font-size: 48px;
            font-weight: 900;
            margin: 0 0 12px;
            background: linear-gradient(135deg, var(--cy) 0%, #0080ff 50%, #ff00ff 100%);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 28px rgba(0, 255, 255, .5);
            animation: titlePulse 3s ease-in-out infinite;
        }

        #game-overlay .brand {
            font-family: Arial, sans-serif;
            font-size: 14px;
            color: #7ba87a;
            /* softer, fresher green */
        }

        #game-overlay .brand-name {
            font-family: Arial, sans-serif;
            font-size: 14px;
            animation: brandPulse 3s ease-in-out infinite;
            text-shadow: 0 0 10px currentColor;
        }

        @keyframes brandPulse {
            0% {
                color: #e24c4b;
                /* vibrant crimson */
            }

            16.66% {
                color: #ff6b35;
                /* bright red-orange */
            }

            33.33% {
                color: #ffb347;
                /* warm orange */
            }

            50% {
                color: #ffd700;
                /* golden yellow */
            }

            66.66% {
                color: #32cd32;
                /* lime green */
            }

            83.33% {
                color: #1e90ff;
                /* bright blue */
            }

            100% {
                color: #e24c4b;
                /* back to crimson */
            }
        }


        @keyframes titlePulse {

            0%,
            100% {
                transform: scale(1)
            }

            50% {
                transform: scale(1.04)
            }
        }

        #game-overlay p {
            font-size: 16px;
            margin: 10px 0 18px;
            color: #d6d6d6;
            line-height: 1.6;
        }

        .overlay-controls {
            display: grid;
            gap: 10px;
            margin: 10px 0 18px;
            grid-template-columns: repeat(2, minmax(180px, 1fr));
            width: min(900px, 100%);
        }

        .toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            justify-content: center;
            background: rgba(255, 255, 255, .05);
            border: 1px solid rgba(255, 255, 255, .12);
            border-radius: 10px;
            padding: 10px;
            color: #eaeaea;
        }

        .toggle input {
            pointer-events: auto;
        }

        .overlay-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }

        .btn {
            pointer-events: auto;
            font-family: 'Orbitron', monospace;
            font-size: 16px;
            font-weight: 800;
            padding: 12px 20px;
            border: 2px solid var(--cy);
            background: linear-gradient(135deg, var(--cy-10) 0%, var(--cy-20) 100%);
            color: var(--cy);
            cursor: pointer;
            border-radius: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all .25s ease;
            backdrop-filter: blur(10px);
        }

        .btn:hover {
            background: linear-gradient(135deg, rgba(0, 255, 255, .25) 0%, rgba(0, 150, 255, .35) 100%);
            transform: translateY(-1px);
        }

        .btn.secondary {
            border-color: rgba(255, 255, 255, .25);
            color: #ddd;
        }

        /* Top bar actions */
        .top-actions {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            pointer-events: auto;
        }

        .icon-btn {
            width: 42px;
            height: 42px;
            border-radius: 10px;
            display: grid;
            place-items: center;
            background: rgba(0, 0, 0, .35);
            border: 1px solid rgba(255, 255, 255, .2);
            color: #fff;
            font-weight: 900;
            font-family: 'Orbitron', monospace;
            cursor: pointer;
        }

        .icon-btn:active {
            transform: translateY(1px) scale(.98);
        }

        /* Achievement feed (text-only, non-blocking) */
        .achievement-feed {
            position: absolute;
            top: 12px;
            right: 12px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            width: min(54vw, 320px);
            pointer-events: none;
            z-index: 200;
        }

        .achievement-line {
            background: rgba(0, 0, 0, .4);
            color: #ffe083;
            border: 1px solid rgba(255, 208, 0, .35);
            border-radius: 8px;
            padding: 6px 10px;
            font-family: 'Orbitron', monospace;
            font-size: 12px;
            font-weight: 800;
            opacity: 0;
            transform: translateY(-8px);
            animation: ach-in .35s ease forwards, ach-out .4s ease 3.2s forwards;
            text-align: right;
        }

        @keyframes ach-in {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes ach-out {
            to {
                opacity: 0;
                transform: translateY(-8px);
            }
        }

        /* Particles for weather (rain) */
        .particle-container {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 50;
        }

        .particle {
            position: absolute;
            width: 2px;
            height: 10px;
            background: rgba(173, 216, 230, .8);
            border-radius: 1px;
            animation: particle-fall linear infinite;
        }

        @keyframes particle-fall {
            from {
                transform: translateY(-10vh);
                opacity: 0;
            }

            10% {
                opacity: 1;
            }

            90% {
                opacity: 1;
            }

            to {
                transform: translateY(100vh);
                opacity: 0;
            }
        }

        /* Touch controls (mobile) */
        .touch-controls {
            position: fixed;
            inset: 0;
            display: grid;
            grid-template-columns: 1fr 1fr;
            pointer-events: none;
            /* children enable */
            z-index: 150;
        }

        .pad {
            display: flex;
            align-items: end;
            justify-content: center;
            padding: 14px;
            gap: 12px;
        }

        .pad.right {
            justify-content: flex-end;
        }

        .pad.left {
            justify-content: flex-start;
        }

        .ctrl-btn {
            pointer-events: auto;
            width: 64px;
            height: 64px;
            border-radius: 14px;
            display: grid;
            place-items: center;
            background: rgba(0, 0, 0, .35);
            border: 1px solid rgba(255, 255, 255, .2);
            color: #fff;
            font-weight: 900;
            font-size: 18px;
            font-family: 'Orbitron', monospace;
            touch-action: none;
        }

        .ctrl-btn.small {
            width: 54px;
            height: 54px;
        }

        .ctrl-btn.nitro {
            width: 96px;
            height: 64px;
            color: #000;
            background: linear-gradient(135deg, rgba(255, 255, 255, .85) 0%, #ffdd55 100%);
            border-color: #ffd84a;
        }

        .mobile-only {
            display: none;
        }

        /* Nitro bar */
        .nitro-bar {
            width: 180px;
            height: 12px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, .2);
            background: rgba(0, 0, 0, .35);
            overflow: hidden;
            position: relative;
        }

        .nitro-fill {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 0%;
            background: linear-gradient(90deg, #36f, #0ff, #0f9);
        }

        @media (max-width: 900px) {
            #game-overlay h1 {
                font-size: 36px;
            }

            .hud-box .value {
                font-size: 20px;
            }

            .speedometer {
                width: 86px;
                height: 86px;
            }

            .minimap {
                width: 100px;
                height: 140px;
            }

            .top-actions {
                top: 8px;
            }

            .icon-btn {
                width: 40px;
                height: 40px;
                border-radius: 10px;
            }

            .mobile-only {
                display: block;
            }
        }

        @media (max-width: 600px) {
            .overlay-controls {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>

<body>
    <div class="particle-container" id="particles"></div>

    <!-- HUD -->
    <div id="hud" aria-hidden="true">
        <div class="top-actions">
            <button id="btn-pause" class="icon-btn" title="Pause/Resume" aria-label="Pause">II</button>
            <button id="btn-mute" class="icon-btn" title="Mute/Unmute" aria-label="Mute">ðŸ”ˆ</button>
        </div>

        <div class="hud-container hud-top-left">
            <div class="hud-box">
                <div class="label">Score</div>
                <div class="value" id="score-val">0</div>
            </div>
            <div class="hud-box mobile-only">
                <div class="label">Nitro</div>
                <div class="nitro-bar">
                    <div class="nitro-fill" id="nitro-fill"></div>
                </div>
            </div>
        </div>

        <div class="hud-container hud-top-right">
            <div class="hud-stats">
                <div class="label">Level</div>
                <div class="value" id="level-val">1</div>
                <div class="label">Gear</div>
                <div class="value" id="gear-val">N</div>
                <div class="label">Distance</div>
                <div class="value" id="distance-val">0.0 KM</div>
                <div class="label">Overtakes</div>
                <div class="value" id="overtake-val">0</div>
                <div class="label">Best Combo</div>
                <div class="value" id="best-combo-val">0</div>
                <div class="label">Accuracy</div>
                <div class="value" id="accuracy-val">100%</div>
            </div>
        </div>

        <div class="hud-container hud-bottom-left">
            <div class="speedometer">
                <div class="speedometer-needle" id="speedometer-needle"></div>
                <div class="speedometer-center"></div>
                <div class="speedometer-text" id="speedometer-text">0</div>
            </div>
            <div class="hud-box desktop-only" style="margin-top:8px;">
                <div class="label">Nitro</div>
                <div class="nitro-bar" style="width:140px;">
                    <div class="nitro-fill" id="nitro-fill-desktop"></div>
                </div>
            </div>
        </div>

        <div class="hud-container hud-bottom-right">
            <div class="minimap">
                <div class="minimap-road"></div>
                <div class="minimap-player" id="minimap-player"></div>
            </div>
        </div>

        <div class="achievement-feed" id="achievement-feed" aria-live="polite"></div>
    </div>

    <!-- Touch Controls -->
    <div class="touch-controls" id="touch-controls" aria-hidden="false">
        <div class="pad left">
            <button class="ctrl-btn small" data-control="left" aria-label="Left">â—€</button>
            <button class="ctrl-btn small" data-control="right" aria-label="Right">â–¶</button>
        </div>
        <div class="pad right">
            <button class="ctrl-btn small" data-control="down" aria-label="Brake">â–¼</button>
            <button class="ctrl-btn small" data-control="up" aria-label="Accelerate">â–²</button>
            <button class="ctrl-btn nitro" data-control="nitro" aria-label="Nitro">NITRO</button>
        </div>
    </div>

    <!-- Overlay -->
    <div id="game-overlay">
        <h1>MR RACER ULTIMATE</h1>
        <p class="brand">
            Made by <span class="brand-name">Vylex Nexys</span> â€¢ Desktop & Mobile<br>
            Overtake traffic to build combos. Achievements appear as small text at the top â€” never blocking your view.
        </p>
        <p>
            Controls:
            <br>- Desktop: Arrow Keys to drive, Space = Nitro, P = Pause
            <br>- Mobile: On-screen buttons, optional Tilt steering
        </p>

        <div class="overlay-controls">
            <label class="toggle">
                <input type="checkbox" id="chk-tilt">
                Enable Tilt Steering (mobile)
            </label>
            <label class="toggle">
                <input type="checkbox" id="chk-lefty">
                Left-handed Controls (move nitro to left)
            </label>
            <label class="toggle">
                <input type="checkbox" id="chk-lowgfx">
                Low Graphics Mode
            </label>
            <label class="toggle">
                <input type="checkbox" id="chk-autoperf" checked>
                Auto Performance Tuning
            </label>
        </div>

        <div class="overlay-buttons">
            <button class="btn" id="btn-start">Start Racing</button>
            <button class="btn secondary" id="btn-tilt-permission" style="display:none;">Enable Motion Access</button>
        </div>

        <p style="opacity:.8; font-size:14px; margin-top:8px;">Tip: Rotate your device to landscape for the best
            experience.</p>
    </div>

    <canvas id="game-canvas"></canvas>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';

        // -------- Core State --------
        let scene, camera, renderer, playerCar;
        let gameStarted = false, paused = false, gameOver = false;
        const keys = Object.create(null);
        const isTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
        const isSmall = () => window.innerWidth < 920;
        let quality = { low: false, autoPerf: true, muted: false };
        let tilt = { enabled: false, lastChange: 0, threshold: 6, cooldownMs: 250 };
        let lefty = false;

        // Gameplay
        let speed = 0;
        let score = 0;
        let distance = 0;
        let overtakes = 0;
        let combo = 0;
        let bestCombo = 0;
        let comboTimer = 0;
        let level = 1;
        let accuracy = 100;
        let crashes = 0;
        let nitroBoost = 100;
        let weather = 'clear';
        let timeOfDay = 0; // [0..1)

        const MAX_SPEED = 1.35;
        const ACCELERATION = 0.0075;
        const BRAKE_POWER = 0.016;
        const FRICTION = 0.0032;
        const NITRO_POWER = 0.022;
        const LANE_WIDTH = 3.6;
        const LANES = [-LANE_WIDTH * 1.5, -LANE_WIDTH * 0.5, LANE_WIDTH * 0.5, LANE_WIDTH * 1.5];
        let currentLane = 1;

        // Objects
        const roadSegments = [];
        const trafficCars = [];
        const sceneryObjects = [];
        const achievements = [];
        const roadSegmentLength = 52;

        // Audio
        let audioContext = null; // lazy
        const sounds = {};
        function ensureAudio() {
            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    initSounds();
                } catch (e) { }
            }
        }

        // HUD refs
        const scoreVal = document.getElementById('score-val');
        const levelVal = document.getElementById('level-val');
        const gearVal = document.getElementById('gear-val');
        const distanceVal = document.getElementById('distance-val');
        const overtakeVal = document.getElementById('overtake-val');
        const bestComboVal = document.getElementById('best-combo-val');
        const accuracyVal = document.getElementById('accuracy-val');
        const speedometerNeedle = document.getElementById('speedometer-needle');
        const speedometerText = document.getElementById('speedometer-text');
        const minimapPlayer = document.getElementById('minimap-player');
        const achievementFeed = document.getElementById('achievement-feed');
        const nitroFillMobile = document.getElementById('nitro-fill');
        const nitroFillDesktop = document.getElementById('nitro-fill-desktop');

        // UI refs
        const overlay = document.getElementById('game-overlay');
        const btnStart = document.getElementById('btn-start');
        const btnTiltPerm = document.getElementById('btn-tilt-permission');
        const chkTilt = document.getElementById('chk-tilt');
        const chkLefty = document.getElementById('chk-lefty');
        const chkLowGfx = document.getElementById('chk-lowgfx');
        const chkAutoPerf = document.getElementById('chk-autoperf');
        const btnPause = document.getElementById('btn-pause');
        const btnMute = document.getElementById('btn-mute');
        const touchControls = document.getElementById('touch-controls');
        const particlesLayer = document.getElementById('particles');

        // Performance tuning
        let frameCount = 0, lastPerfCheck = performance.now();
        let targetPixelRatio = Math.min(window.devicePixelRatio, 2);
        let miniMapUpdateTimer = 0;

        // Storage
        const save = (k, v) => localStorage.setItem(k, JSON.stringify(v));
        const load = (k, d) => { try { return JSON.parse(localStorage.getItem(k)) ?? d; } catch { return d; } };

        // -------- Init --------
        function init() {
            // Load settings
            quality.low = load('mr.lowgfx', false);
            quality.autoPerf = load('mr.autoperf', true);
            lefty = load('mr.lefty', false);
            tilt.enabled = load('mr.tilt', false);
            quality.muted = load('mr.muted', false);

            chkLowGfx.checked = quality.low;
            chkAutoPerf.checked = quality.autoPerf;
            chkLefty.checked = lefty;
            chkTilt.checked = tilt.enabled;
            btnMute.textContent = quality.muted ? 'ðŸ”‡' : 'ðŸ”ˆ';

            // Scene + camera + renderer
            scene = new THREE.Scene();
            updateEnvironment(true);

            camera = new THREE.PerspectiveCamera(74, window.innerWidth / window.innerHeight, 0.1, 240);
            camera.position.set(0, 4.2, 6.4);
            camera.rotation.x = -0.12;

            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('game-canvas'),
                antialias: !quality.low,
                powerPreference: 'high-performance',
                alpha: false
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(targetPixelRatio);
            renderer.shadowMap.enabled = !quality.low;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = quality.low ? 1.0 : 1.15;

            createLights();
            createPlayerCar();
            createRoad();
            createScenery();
            createTraffic(isTouch || isSmall() ? 12 : 18);
            createWeatherParticles();
            setupInputs();

            if (isTouch && typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                btnTiltPerm.style.display = 'inline-block';
            }

            // UI listeners
            window.addEventListener('resize', onResize);
            btnStart.addEventListener('click', startGame);
            btnTiltPerm.addEventListener('click', requestMotionPermission);
            btnPause.addEventListener('click', togglePause);
            btnMute.addEventListener('click', toggleMute);

            chkLowGfx.addEventListener('change', () => {
                quality.low = chkLowGfx.checked; save('mr.lowgfx', quality.low);
                applyGraphicsQuality();
            });
            chkAutoPerf.addEventListener('change', () => {
                quality.autoPerf = chkAutoPerf.checked; save('mr.autoperf', quality.autoPerf);
            });
            chkLefty.addEventListener('change', () => {
                lefty = chkLefty.checked; save('mr.lefty', lefty);
                layoutTouchControls();
            });
            chkTilt.addEventListener('change', () => {
                tilt.enabled = chkTilt.checked; save('mr.tilt', tilt.enabled);
            });

            layoutTouchControls();
        }

        function startGame() {
            gameStarted = true; paused = false; gameOver = false;
            overlay.style.display = 'none';
            resetGame();
            ensureAudio();
            animate();
        }

        function resetGame() {
            speed = 0; score = 0; distance = 0;
            overtakes = 0; combo = 0; bestCombo = 0; comboTimer = 0;
            level = 1; accuracy = 100; crashes = 0; nitroBoost = 100;
            currentLane = 1; timeOfDay = Math.random(); weather = Math.random() > 0.78 ? 'rain' : 'clear';

            playerCar.position.set(LANES[currentLane], 0.42, 0);
            playerCar.rotation.set(0, 0, 0);

            trafficCars.forEach(car => resetTrafficCar(car, true));
            updateEnvironment(true);
            updateWeatherParticles();
        }

        // -------- Scene Creation --------
        function createLights() {
            const amb = new THREE.AmbientLight(0x404040, 0.48);
            scene.add(amb);

            const sun = new THREE.DirectionalLight(0xffffff, 0.95);
            sun.position.set(60, 70, 35);
            sun.castShadow = !quality.low;
            sun.shadow.mapSize.set(1024, 1024);
            sun.shadow.camera.near = 0.5;
            sun.shadow.camera.far = 260;
            sun.shadow.camera.left = -60; sun.shadow.camera.right = 60;
            sun.shadow.camera.top = 60; sun.shadow.camera.bottom = -60;
            scene.add(sun);

            // Some street lights
            for (let i = 0; i < 10; i++) {
                const lamp = new THREE.PointLight(0xffa500, 0.35, 20);
                lamp.position.set((i % 2 ? -1 : 1) * 8.8, 6.2, -i * 30);
                lamp.castShadow = false;
                scene.add(lamp);
            }
        }

        function updateEnvironment(force = false) {
            const skyDay = new THREE.Color(0x87CEEB);
            const skySun = new THREE.Color(0xFF7F50);
            const skyNight = new THREE.Color(0x0d1030);

            let col;
            if (timeOfDay < 0.33) col = skyDay;
            else if (timeOfDay < 0.66) col = skySun;
            else col = skyNight;

            if (force) {
                scene.background = col;
                scene.fog = new THREE.Fog(col, 22, 140);
            } else {
                scene.background.lerp(col, 0.02);
                const f = scene.fog;
                f.color.lerp(col, 0.02);
            }
        }

        function createPlayerCar() {
            const g = new THREE.Group();

            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x00ff88, metalness: 0.85, roughness: 0.28 });
            const body = new THREE.Mesh(new THREE.BoxGeometry(1.85, 0.8, 3.9), bodyMat);
            body.castShadow = !quality.low; g.add(body);

            const cabinMat = new THREE.MeshStandardMaterial({ color: 0x222831, metalness: 0.1, roughness: 0.1, transparent: true, opacity: 0.78 });
            const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.7, 2.3), cabinMat);
            cabin.position.set(0, 0.76, -0.1); g.add(cabin);

            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: .6 });
            const wGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.18, 10);
            [[-0.8, -0.2, 1.15], [0.8, -0.2, 1.15], [-0.8, -0.2, -1.15], [0.8, -0.2, -1.15]].forEach(p => {
                const w = new THREE.Mesh(wGeo, wheelMat); w.position.set(...p); w.rotation.z = Math.PI / 2; w.castShadow = !quality.low; g.add(w);
            });

            // headlights
            const headGeo = new THREE.SphereGeometry(0.14, 8, 8);
            const headMat = new THREE.MeshBasicMaterial({ color: 0xffffaa });
            [[-0.58, .22, 1.8], [0.58, .22, 1.8]].forEach(p => {
                const m = new THREE.Mesh(headGeo, headMat); m.position.set(...p); g.add(m);
                const L = new THREE.PointLight(0xffffaa, 0.55, 14); L.position.copy(m.position); g.add(L);
            });

            g.position.y = 0.42;
            playerCar = g;
            scene.add(g);
        }

        function createRoad() {
            const roadMat = new THREE.MeshStandardMaterial({ color: 0x3e3e3e, roughness: 0.86, metalness: 0.08 });
            const roadGeo = new THREE.PlaneGeometry(LANE_WIDTH * 4 + 8, roadSegmentLength);

            const grassGeo = new THREE.PlaneGeometry(220, roadSegmentLength);
            const grassColors = [0x255b2b, 0x2e6b30, 0x3b7f3c];

            for (let i = 0; i < 6; i++) {
                const road = new THREE.Mesh(roadGeo, roadMat);
                road.rotation.x = -Math.PI / 2;
                road.position.z = -i * roadSegmentLength;
                road.receiveShadow = true;
                roadSegments.push(road);
                scene.add(road);

                // lane markings
                const markMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const markGeo = new THREE.PlaneGeometry(0.16, roadSegmentLength);
                for (let j = 0; j < 3; j++) {
                    const m = new THREE.Mesh(markGeo, markMat);
                    m.rotation.x = -Math.PI / 2;
                    m.position.set((j - 1) * LANE_WIDTH, 0.011, -i * roadSegmentLength);
                    scene.add(m);
                }

                // grass
                [-110, 110].forEach(x => {
                    const grassMat = new THREE.MeshStandardMaterial({ color: grassColors[Math.floor(Math.random() * grassColors.length)], roughness: 1 });
                    const grass = new THREE.Mesh(grassGeo, grassMat);
                    grass.rotation.x = -Math.PI / 2;
                    grass.position.set(x, -0.02, -i * roadSegmentLength);
                    grass.receiveShadow = true;
                    scene.add(grass);
                });
            }
        }

        function createScenery() {
            const createTree = (x, z, type = 'pine') => {
                const group = new THREE.Group();
                if (type === 'pine') {
                    const cone = new THREE.Mesh(new THREE.ConeGeometry(1 + Math.random(), 3.6 + Math.random() * 1.6, 8), new THREE.MeshStandardMaterial({ color: 0x1f7a1f }));
                    cone.position.y = 2.8; cone.castShadow = !quality.low; group.add(cone);
                } else {
                    const sph = new THREE.Mesh(new THREE.SphereGeometry(1.4 + Math.random() * 0.8, 8, 6), new THREE.MeshStandardMaterial({ color: 0x32cd32 }));
                    sph.position.y = 3.1; sph.castShadow = !quality.low; group.add(sph);
                }
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(.2, .3, 1.8 + Math.random() * 0.6), new THREE.MeshStandardMaterial({ color: 0x8b5a2b }));
                trunk.position.y = .9; trunk.castShadow = !quality.low; group.add(trunk);

                group.position.set(x, 0, z);
                sceneryObjects.push(group);
                scene.add(group);
            };

            const createBuilding = (x, z) => {
                const grp = new THREE.Group();
                const h = 6 + Math.random() * 13;
                const w = 2 + Math.random() * 3;
                const d = 2 + Math.random() * 3;
                const mat = new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL(Math.random(), .28, .5) });
                const box = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
                box.position.y = h / 2; box.castShadow = !quality.low; grp.add(box);
                grp.position.set(x, 0, z);
                sceneryObjects.push(grp); scene.add(grp);
            };

            for (let i = 0; i < 42; i++) {
                const x = (Math.random() > 0.5 ? 1 : -1) * (LANE_WIDTH * 2.5 + 6 + Math.random() * 22);
                const z = -Math.random() * 340;
                if (Math.abs(x) > 15) {
                    if (Math.random() > 0.68) createBuilding(x, z);
                    else createTree(x, z, Math.random() > 0.6 ? 'pine' : 'oak');
                } else {
                    createTree(x, z);
                }
            }
        }

        function createTraffic(count = 16) {
            const types = [
                { name: 'sedan', size: [1.8, 1.2, 4], color: null },
                { name: 'suv', size: [2.2, 1.7, 4.4], color: null },
                { name: 'truck', size: [2.6, 2.6, 8], color: 0xcccccc },
                { name: 'sports', size: [1.6, 1.0, 3.7], color: null },
                { name: 'hatch', size: [1.7, 1.25, 3.6], color: null }
            ];
            const colors = [0xff3b30, 0x007aff, 0xffffff, 0x000000, 0x8e44ad, 0x2ecc71, 0xff9500, 0x00d1ff];

            for (let i = 0; i < count; i++) {
                const t = types[Math.floor(Math.random() * types.length)];
                const g = new THREE.Group();
                const color = t.color ?? colors[Math.floor(Math.random() * colors.length)];
                const body = new THREE.Mesh(new THREE.BoxGeometry(...t.size), new THREE.MeshStandardMaterial({ color, metalness: .6, roughness: .45 }));
                body.castShadow = !quality.low; g.add(body);

                // wheels
                const wheelMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
                const wGeo = new THREE.CylinderGeometry(0.25, 0.25, 0.15, 8);
                const wheelCount = t.name === 'truck' ? 6 : 4;
                const spacing = t.size[2] / (wheelCount === 6 ? 3 : 2);
                for (let j = 0; j < wheelCount; j++) {
                    [-t.size[0] * 0.4, t.size[0] * 0.4].forEach(x => {
                        const w = new THREE.Mesh(wGeo, wheelMat);
                        w.position.set(x, -t.size[1] * 0.4, t.size[2] * 0.3 - j * spacing);
                        w.rotation.z = Math.PI / 2; w.castShadow = !quality.low; g.add(w);
                    });
                }
                g.position.y = t.size[1] / 2;
                g.userData.type = t.name;
                scene.add(g);
                trafficCars.push(g);
            }
            trafficCars.forEach(c => resetTrafficCar(c, true));
        }

        function resetTrafficCar(car, initial = false) {
            car.userData.speed = (Math.random() * 0.22 + 0.10) * (1 + level * 0.02);
            car.userData.overtaken = false;
            car.userData.targetX = undefined;
            car.position.x = LANES[Math.floor(Math.random() * LANES.length)];
            car.position.z = initial ? -Math.random() * 260 - 40 : -200 - Math.random() * 140;
        }

        // -------- Weather Particles --------
        function createWeatherParticles() {
            for (let i = 0; i < 120; i++) {
                const p = document.createElement('div');
                p.className = 'particle';
                p.style.left = (Math.random() * 100) + '%';
                p.style.animationDelay = (Math.random() * 2) + 's';
                p.style.animationDuration = (Math.random() * 2 + 2.4) + 's';
                particlesLayer.appendChild(p);
            }
            updateWeatherParticles();
        }

        function updateWeatherParticles() {
            const list = particlesLayer.children;
            for (const el of list) {
                if (weather === 'rain') {
                    el.style.display = 'block';
                } else {
                    el.style.display = 'none';
                }
            }
        }

        // -------- Audio --------
        function initSounds() {
            sounds.overtake = () => beep(440, 0.08, 0.06);
            sounds.lane = () => beep(270, 0.05, 0.05);
            sounds.nitro = () => beep(880, 0.16, 0.09);
            sounds.crash = () => noise(0.26, 0.08);
            sounds.ach = () => { beep(523, .08, .06); setTimeout(() => beep(659, .08, .06), 90); setTimeout(() => beep(784, .16, .08), 180); }
        }
        function beep(freq, dur, vol = 0.08) {
            if (!audioContext || quality.muted) return;
            const o = audioContext.createOscillator();
            const g = audioContext.createGain();
            o.connect(g); g.connect(audioContext.destination);
            o.frequency.value = freq; o.type = 'square';
            g.gain.setValueAtTime(vol, audioContext.currentTime);
            g.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + dur);
            o.start(); o.stop(audioContext.currentTime + dur);
        }
        function noise(dur = 0.2, vol = 0.08) {
            if (!audioContext || quality.muted) return;
            const size = audioContext.sampleRate * dur;
            const buffer = audioContext.createBuffer(1, size, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < size; i++) data[i] = Math.random() * 2 - 1;
            const src = audioContext.createBufferSource(); src.buffer = buffer;
            const g = audioContext.createGain(); g.gain.value = vol;
            src.connect(g); g.connect(audioContext.destination);
            src.start(); setTimeout(() => src.stop(), dur * 1000);
        }
        function playSound(name) {
            try { ensureAudio(); sounds[name] && sounds[name](); } catch { }
        }
        function toggleMute() {
            quality.muted = !quality.muted;
            btnMute.textContent = quality.muted ? 'ðŸ”‡' : 'ðŸ”ˆ';
            save('mr.muted', quality.muted);
        }

        // -------- Inputs --------
        function setupInputs() {
            window.addEventListener('keydown', e => {
                keys[e.code] = true;
                if (e.code === 'KeyP') togglePause();
                if (!gameStarted || gameOver) return;
                if (e.code === 'ArrowLeft' && !keys['_left_once']) { laneLeft(); keys['_left_once'] = true; playSound('lane'); }
                if (e.code === 'ArrowRight' && !keys['_right_once']) { laneRight(); keys['_right_once'] = true; playSound('lane'); }
                if (e.code === 'Space') { keys['nitro'] = true; playSound('nitro'); }
            });
            window.addEventListener('keyup', e => {
                keys[e.code] = false;
                if (e.code === 'ArrowLeft') keys['_left_once'] = false;
                if (e.code === 'ArrowRight') keys['_right_once'] = false;
                if (e.code === 'Space') keys['nitro'] = false;
            });

            // Touch buttons
            touchControls.querySelectorAll('.ctrl-btn').forEach(btn => {
                const ctl = btn.getAttribute('data-control');
                const on = (v) => {
                    if (ctl === 'left' && v) { laneLeft(); playSound('lane'); }
                    else if (ctl === 'right' && v) { laneRight(); playSound('lane'); }
                    else if (ctl === 'up') keys['ArrowUp'] = v;
                    else if (ctl === 'down') keys['ArrowDown'] = v;
                    else if (ctl === 'nitro') { keys['nitro'] = v; if (v) playSound('nitro'); }
                };
                btn.addEventListener('pointerdown', e => { e.preventDefault(); on(true); btn.setPointerCapture(e.pointerId); });
                btn.addEventListener('pointerup', () => on(false));
                btn.addEventListener('pointercancel', () => on(false));
                btn.addEventListener('pointerleave', () => on(false));
            });

            // Swipe gestures
            let touchStart = null;
            window.addEventListener('touchstart', e => {
                if (!e.target.closest('.ctrl-btn')) touchStart = { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY, t: performance.now() };
            }, { passive: true });
            window.addEventListener('touchend', e => {
                if (!touchStart) return;
                const dx = e.changedTouches[0].clientX - touchStart.x;
                const dy = e.changedTouches[0].clientY - touchStart.y;
                const adx = Math.abs(dx), ady = Math.abs(dy);
                if (Math.max(adx, ady) > 24) {
                    if (adx > ady) { dx < 0 ? laneLeft() : laneRight(); playSound('lane'); }
                    else { dy < 0 ? keys['ArrowUp'] = true : keys['ArrowDown'] = true; setTimeout(() => { keys['ArrowUp'] = false; keys['ArrowDown'] = false; }, 180); }
                }
                touchStart = null;
            });

            // Tilt steering
            window.addEventListener('deviceorientation', e => {
                if (!tilt.enabled || !gameStarted || paused || gameOver) return;
                const gamma = e.gamma; // left/right tilt
                const now = performance.now();
                if (gamma < -tilt.threshold && now - tilt.lastChange > tilt.cooldownMs) { laneLeft(); playSound('lane'); tilt.lastChange = now; }
                else if (gamma > tilt.threshold && now - tilt.lastChange > tilt.cooldownMs) { laneRight(); playSound('lane'); tilt.lastChange = now; }
            });
        }

        async function requestMotionPermission() {
            try {
                if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                    const res = await DeviceMotionEvent.requestPermission();
                    if (res === 'granted') {
                        btnTiltPerm.style.display = 'none';
                        showToast('Motion access granted');
                    } else {
                        showToast('Motion access denied');
                    }
                }
            } catch { }
        }

        function laneLeft() { currentLane = Math.max(0, currentLane - 1); }
        function laneRight() { currentLane = Math.min(LANES.length - 1, currentLane + 1); }

        function togglePause() {
            if (!gameStarted || gameOver) return;
            paused = !paused;
            overlay.style.display = paused ? 'flex' : 'none';
            overlay.querySelector('h1').textContent = paused ? 'Paused' : 'MR RACER ULTIMATE';
            overlay.querySelector('p').innerHTML = paused
                ? 'Game paused. Tap Resume to continue.'
                : 'Experience the ultimate racing challenge!';
            btnStart.textContent = paused ? 'Resume' : 'Start Racing';
        }

        // -------- Game Loop --------
        function animate() {
            if (!gameStarted) return;
            requestAnimationFrame(animate);
            if (paused || gameOver) return;

            handleInput();
            updateState();
            checkCollisions();
            updateHUD();
            maybeUpdateMinimap();

            renderer.render(scene, camera);

            // Auto performance adapt
            if (quality.autoPerf) {
                frameCount++;
                const now = performance.now();
                if (now - lastPerfCheck > 1600) {
                    const fps = frameCount * 1000 / (now - lastPerfCheck);
                    adaptPerformance(fps);
                    frameCount = 0; lastPerfCheck = now;
                }
            }
        }

        function handleInput() {
            if (keys['ArrowUp']) speed = Math.min(MAX_SPEED, speed + ACCELERATION);
            else if (keys['ArrowDown']) speed = Math.max(0, speed - BRAKE_POWER);
            else speed = Math.max(0, speed - FRICTION);

            if (keys['nitro'] && nitroBoost > 0) {
                speed = Math.min(MAX_SPEED * 1.55, speed + NITRO_POWER);
                nitroBoost = Math.max(0, nitroBoost - 0.6);
            } else if (nitroBoost < 100) {
                nitroBoost = Math.min(100, nitroBoost + 0.12);
            }
        }

        function updateState() {
            // player lane target + tilt and tilt-like easing
            const targetX = LANES[currentLane];
            playerCar.position.x = THREE.MathUtils.lerp(playerCar.position.x, targetX, 0.16);

            // tilt visual
            const visualTilt = (targetX - playerCar.position.x) * 0.22;
            playerCar.rotation.z = THREE.MathUtils.lerp(playerCar.rotation.z, visualTilt, 0.1);

            // camera follow
            camera.position.z = playerCar.position.z + 6.2 + speed * 2.1;
            camera.position.y = 4.2 + speed * 1.4;
            camera.position.x = THREE.MathUtils.lerp(camera.position.x, playerCar.position.x * 0.28, 0.12);

            // time of day animation
            timeOfDay += 0.00046; if (timeOfDay > 1) timeOfDay = 0;
            updateEnvironment(false);

            // move road
            roadSegments.forEach(r => {
                r.position.z += speed;
                if (r.position.z > roadSegmentLength) r.position.z -= roadSegments.length * roadSegmentLength;
            });

            // move scenery
            sceneryObjects.forEach(o => {
                o.position.z += speed;
                if (o.position.z > camera.position.z + 24) o.position.z = -340 - Math.random() * 80;
            });

            // traffic AI
            for (const car of trafficCars) {
                car.position.z += speed - car.userData.speed;

                // occasional lane change target
                if (Math.random() < 0.0012) {
                    const nearestLaneIdx = nearestLaneIndex(car.position.x);
                    const dir = Math.random() > 0.5 ? 1 : -1;
                    const newLane = THREE.MathUtils.clamp(nearestLaneIdx + dir, 0, LANES.length - 1);
                    car.userData.targetX = LANES[newLane];
                }
                if (car.userData.targetX !== undefined) {
                    car.position.x = THREE.MathUtils.lerp(car.position.x, car.userData.targetX, 0.02);
                }

                // overtake detection (when car goes behind camera/player)
                if (!car.userData.overtaken && car.position.z > camera.position.z + 6) {
                    handleOvertake(car);
                }

                // recycle far behind
                if (car.position.z > camera.position.z + 28) resetTrafficCar(car, false);
            }

            // combo timer
            if (comboTimer > 0) {
                comboTimer -= 1 / 60;
            } else if (combo > 0) {
                combo = 0;
            }

            // level progression
            const newLevel = Math.floor(distance / 5) + 1;
            if (newLevel > level) {
                level = newLevel;
                pushAchievement(`Level ${level} reached`);
                trafficCars.forEach(c => c.userData.speed *= 1.04);
            }

            // stats
            const kph = Math.floor(speed * 210);
            distance += (kph / 3600) / 60;
            score += Math.floor(kph / 12) + level;

            // achievements
            checkAchievements(kph);
        }

        function handleOvertake(car) {
            const pts = 100 * (combo + 1) * level;
            score += pts;
            overtakes++;
            combo++; bestCombo = Math.max(bestCombo, combo);
            comboTimer = 3.2;
            car.userData.overtaken = true;

            playSound('overtake');
            floatPoint(`+${pts}`, '#00ff88');
        }

        function checkAchievements(kph) {
            if (kph > 160 && !achievements.includes('spd160')) { achievements.push('spd160'); pushAchievement('Speed Demon: 160+ KPH'); }
            if (combo >= 10 && !achievements.includes('combo10')) { achievements.push('combo10'); pushAchievement('Combo Master: x10'); }
            if (distance > 25 && !achievements.includes('dist25')) { achievements.push('dist25'); pushAchievement('Traveller: 25 KM'); }
            if (distance > 50 && !achievements.includes('dist50')) { achievements.push('Long Hauler: 50 KM'); }
            if (overtakes >= 50 && !achievements.includes('ov50')) { achievements.push('ov50'); pushAchievement('Overtake Pro: 50'); }
            if (overtakes >= 100 && !achievements.includes('ov100')) { achievements.push('ov100'); pushAchievement('Overtake Champion: 100'); }
        }

        function checkCollisions() {
            // optimize: only check cars close in Z and same lane
            const playerZ = playerCar.position.z;
            const laneX = LANES[currentLane];
            for (const car of trafficCars) {
                const dz = Math.abs(car.position.z - playerZ);
                if (dz > 4.8) continue;
                if (Math.abs(nearestLaneX(car.position.x) - laneX) > LANE_WIDTH * 0.5) continue;
                // AABB quick
                const px = playerCar.position.x, pz = playerCar.position.z;
                const cx = car.position.x, cz = car.position.z;
                const halfW = 0.9, halfL = 1.9;
                const halfWc = 1.2, halfLc = 2.4;
                if (Math.abs(px - cx) < (halfW + halfWc) && Math.abs(pz - cz) < (halfL + halfLc)) {
                    onCrash();
                    break;
                }
            }
        }

        function onCrash() {
            crashes++;
            accuracy = Math.max(0, Math.floor((overtakes / Math.max(1, overtakes + crashes)) * 100));
            playSound('crash');
            if (navigator.vibrate) navigator.vibrate(120);
            endGame();
        }

        function endGame() {
            gameOver = true; paused = false;
            overlay.style.display = 'flex';
            const title = overlay.querySelector('h1');
            const info = overlay.querySelector('p');
            title.textContent = 'Race Complete';
            info.innerHTML = `
                <strong>Final Stats</strong><br>
                Score: ${score.toLocaleString()}<br>
                Level: ${level}<br>
                Distance: ${distance.toFixed(1)} KM<br>
                Overtakes: ${overtakes}<br>
                Best Combo: ${bestCombo}<br>
                Accuracy: ${accuracy}%<br>
                ${saveBest()}
            `;
            btnStart.textContent = 'Race Again';

            pushAchievement('Race Complete!');
        }

        function saveBest() {
            const best = load('mr.best', { score: 0, dist: 0, combo: 0 });
            let improved = [];
            if (score > best.score) { best.score = score; improved.push('Best score!'); }
            if (distance > best.dist) { best.dist = distance; improved.push('Best distance!'); }
            if (bestCombo > best.combo) { best.combo = bestCombo; improved.push('Best combo!'); }
            save('mr.best', best);
            return improved.length ? `<br><span style="color:${'var(--ok)'}">${improved.join(' ')}</span>` : '';
        }

        // -------- HUD / UI --------
        function updateHUD() {
            scoreVal.textContent = score.toLocaleString();
            levelVal.textContent = level;
            distanceVal.textContent = `${distance.toFixed(1)} KM`;
            overtakeVal.textContent = overtakes;
            bestComboVal.textContent = bestCombo;
            accuracyVal.textContent = `${accuracy}%`;

            const kph = Math.floor(speed * 210);
            speedometerText.textContent = kph;
            const needleRotation = (kph / 210) * 180 - 90;
            speedometerNeedle.style.transform = `translate(-50%, -100%) rotate(${needleRotation}deg)`;

            if (kph < 1) gearVal.textContent = 'N';
            else if (kph < 25) gearVal.textContent = '1';
            else if (kph < 50) gearVal.textContent = '2';
            else if (kph < 80) gearVal.textContent = '3';
            else if (kph < 110) gearVal.textContent = '4';
            else if (kph < 140) gearVal.textContent = '5';
            else gearVal.textContent = '6';

            const nitroPct = Math.max(0, Math.min(100, nitroBoost));
            if (nitroFillMobile) nitroFillMobile.style.width = nitroPct + '%';
            if (nitroFillDesktop) nitroFillDesktop.style.width = nitroPct + '%';
        }

        function maybeUpdateMinimap() {
            miniMapUpdateTimer++;
            if (miniMapUpdateTimer % 3) return; // reduce DOM churn
            const minimap = document.querySelector('.minimap');
            document.querySelectorAll('.minimap-traffic').forEach(d => d.remove());

            const lanePercent = (currentLane / (LANES.length - 1)) * 100;
            minimapPlayer.style.left = `${20 + lanePercent * 0.6}%`;

            for (const car of trafficCars) {
                const relZ = car.position.z - camera.position.z;
                if (relZ > -90 && relZ < 26) {
                    const dot = document.createElement('div');
                    dot.className = 'minimap-traffic';
                    const carLane = nearestLaneIndex(car.position.x);
                    const carLanePercent = (carLane / (LANES.length - 1)) * 100;
                    const zPercent = ((relZ + 90) / 116) * 100;
                    dot.style.left = `${20 + carLanePercent * 0.6}%`;
                    dot.style.top = `${100 - zPercent}%`;
                    minimap.appendChild(dot);
                }
            }
        }

        function pushAchievement(text) {
            // Text-only, tiny toast at top-right (non-blocking)
            const line = document.createElement('div');
            line.className = 'achievement-line';
            line.textContent = text;
            achievementFeed.appendChild(line);
            if (achievementFeed.children.length > 4) {
                achievementFeed.firstElementChild.remove();
            }
            playSound('ach');
        }

        function floatPoint(text, color = '#00ff00') {
            const el = document.createElement('div');
            el.style.position = 'fixed';
            el.style.top = '50%'; el.style.left = '50%';
            el.style.transform = 'translate(-50%, -50%)';
            el.style.color = color; el.style.fontSize = '22px'; el.style.fontWeight = '800';
            el.style.textShadow = '0 0 8px rgba(0,0,0,.6)';
            el.style.pointerEvents = 'none'; el.style.zIndex = '999';
            el.style.animation = 'fade-up 0.9s ease-out forwards';
            el.textContent = text; document.body.appendChild(el);
            setTimeout(() => el.remove(), 900);
        }

        // bonus text animation
        (() => {
            const st = document.createElement('style');
            st.textContent = `
                @keyframes fade-up {
                    0% { opacity: 1; transform: translate(-50%, -50%); }
                    100% { opacity: 0; transform: translate(-50%, -150%); }
                }
            `;
            document.head.appendChild(st);
        })();

        // -------- Utils --------
        function nearestLaneIndex(x) {
            let best = 0, bestD = Infinity;
            for (let i = 0; i < LANES.length; i++) { const d = Math.abs(LANES[i] - x); if (d < bestD) { bestD = d; best = i; } }
            return best;
        }
        function nearestLaneX(x) { return LANES[nearestLaneIndex(x)]; }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (quality.autoPerf) {
                targetPixelRatio = Math.min(window.devicePixelRatio, 2);
                renderer.setPixelRatio(targetPixelRatio);
            }
            layoutTouchControls();
        }

        function layoutTouchControls() {
            if (!isTouch) { touchControls.style.display = 'none'; return; }
            touchControls.style.display = 'grid';
            const pads = touchControls.querySelectorAll('.pad');
            pads.forEach(p => p.classList.remove('left', 'right'));
            const [leftPad, rightPad] = touchControls.children;
            if (lefty) {
                leftPad.classList.add('right'); rightPad.classList.add('left');
                rightPad.style.justifyContent = 'flex-start';
                leftPad.style.justifyContent = 'flex-end';
            } else {
                leftPad.classList.add('left'); rightPad.classList.add('right');
                leftPad.style.justifyContent = 'flex-start';
                rightPad.style.justifyContent = 'flex-end';
            }
        }

        function applyGraphicsQuality() {
            renderer.antialias = !quality.low;
            renderer.shadowMap.enabled = !quality.low;
            renderer.toneMappingExposure = quality.low ? 1.0 : 1.15;
            // simplify immediate effects: lower pixel ratio in low mode
            const pr = quality.low ? Math.min(window.devicePixelRatio, 1.25) : Math.min(window.devicePixelRatio, 2);
            renderer.setPixelRatio(pr);
        }

        function adaptPerformance(fps) {
            // Adapt renderer pixel ratio to keep ~55-60 fps on most devices
            const pr = renderer.getPixelRatio();
            if (fps < 45 && pr > 0.9) {
                renderer.setPixelRatio(Math.max(0.75, pr - 0.15));
            } else if (fps > 65 && pr < Math.min(2, window.devicePixelRatio)) {
                renderer.setPixelRatio(Math.min(Math.min(2, window.devicePixelRatio), pr + 0.1));
            }
        }

        // -------- Start --------
        init();

        // --------------- Original features kept and improved ---------------
        // Everything on-road is a car (no blocking achievement popups).
        // Mobile: on-screen controls, swipe, optional tilt.
        // Desktop: keys + pause + nitro.
        // Text-only achievements as toasts at top-right.

        // ---- Extra: minor polishing timer ----
        setInterval(() => {
            if (!gameStarted || paused || gameOver) return;
            // small camera shake on high speed
            const s = Math.min(1, speed / MAX_SPEED);
            camera.rotation.z = (Math.random() - 0.5) * 0.002 * s;
        }, 120);
    </script>
</body>

</html>
