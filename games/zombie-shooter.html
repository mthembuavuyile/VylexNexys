<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Zombie Shooter - Vylex nexys</title>
    <meta name="description" content="Survive the waves! A 3D zombie shooter game by Avuyile Mthembu (Vylex nexys). Move, aim, and shoot your way through hordes of the undead.">
    <meta name="keywords" content="zombie shooter, 3d game, web game, html5 game, three.js, survival, shooter, Vylex nexys, Avuyile Mthembu">
    <meta name="author" content="Avuyile Mthembu, Vylex nexys">
    <meta property="og:type" content="website">
    <meta property="og:url" content="vylexnexys.co.za/games/xombie-shooter"> <meta property="og:title" content="Zombie Shooter - Vylex nexys">
    <meta property="og:description" content="Survive the waves! A 3D zombie shooter game by Avuyile Mthembu (Vylex nexys).">
    <meta property="og:image" content="[URL_TO_YOUR_GAME_PREVIEW_IMAGE_HERE]"> <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="[YOUR_GAME_URL_HERE]"> <meta property="twitter:title" content="Zombie Shooter - Vylex nexys">
    <meta property="twitter:description" content="Survive the waves! A 3D zombie shooter game by Avuyile Mthembu (Vylex nexys).">
    <meta property="twitter:image" content="[URL_TO_YOUR_GAME_PREVIEW_IMAGE_HERE]"> <link rel="icon" href="favicon.ico" type="image/x-icon">

    <style>
        body {
    margin: 0;
    overflow: hidden;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    touch-action: none;
    background-color: #000; /* Ensure black background on load */
}

#gameCanvas {
    display: block;
    cursor: pointer;
}

#ui {
    position: absolute;
    top: 20px;
    left: 20px;
    color: white;
    font-size: 24px;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    user-select: none;
    display: none;
}

.screen-overlay {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(to bottom right, #111, #000);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 10;
    color: #ffffff;
    text-align: center;
    padding: 20px;
    box-sizing: border-box;
    animation: fadeIn 1s ease-in-out;
}

.screen-overlay h1 {
    font-size: clamp(2.5rem, 6vw, 4.5rem);
    margin-bottom: 1rem;
    letter-spacing: 2px;
    text-transform: uppercase;
    text-shadow: 3px 3px 10px rgba(255, 0, 0, 0.8);
}

.screen-overlay p {
    font-size: clamp(1rem, 2.2vw, 1.5rem);
    margin-bottom: 2rem;
    max-width: 90%;
    line-height: 1.7;
}

.branding {
    font-size: clamp(0.9rem, 1.2vw, 1.1rem);
    color: #cccccc;
    margin-bottom: 2rem;
    font-style: italic;
    text-shadow: 1px 1px 5px rgba(255, 255, 255, 0.2);
}

button {
    border: none;
    color: white;
    padding: 12px 28px;
    font-size: 1.2rem;
    margin: 8px;
    cursor: pointer;
    border-radius: 12px;
    background-color: #333;
    transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.2s ease;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
}

button:hover {
    transform: scale(1.07);
    box-shadow: 0 6px 14px rgba(0, 0, 0, 0.5);
}

#startButton { background-color: #4CAF50; }
#restartButtonGameOver,
#restartButtonPause { background-color: #f44336; }
#resumeButton { background-color: #2196F3; }
#viewToggleButton { background-color: #9c27b0; }

@media (max-width: 768px) {
    .screen-overlay p {
        font-size: 1rem;
    }
    button {
        font-size: 1rem;
        padding: 10px 20px;
    }
}

#startScreen, #gameOver, #pauseScreen {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 10;
    color: white;
    text-align: center;
}

/* Enhanced Start Screen */
#startScreen {
    background: radial-gradient(circle at center, #300, #000);
    overflow: hidden;
    position: relative;
}

#startScreen::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><rect fill="none" width="100" height="100"/><path fill="rgba(255,0,0,0.03)" d="M0 0L100 100ZM100 0L0 100Z"/></svg>');
    opacity: 0.4;
    z-index: -1;
}

#startScreen h1 {
    font-size: clamp(3rem, 10vw, 6rem);
    text-transform: uppercase;
    margin: 0 0 20px;
    letter-spacing: 4px;
    text-shadow: 
        0 0 10px rgba(255,0,0,0.8),
        0 0 20px rgba(255,0,0,0.5),
        0 0 30px rgba(255,0,0,0.3),
        0 0 40px rgba(255,0,0,0.1);
    animation: pulse 4s infinite alternate;
    position: relative;
}

#startScreen h1::after {
    content: 'ZOMBIE SHOOTER';
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    color: rgba(255,255,255,0.1);
    z-index: -1;
    filter: blur(8px);
}

#startScreen .branding {
    font-size: calc(14px + 0.5vw);
    color: #bebc0f;
    margin: 5px 0 25px;
    letter-spacing: 1px;
    position: relative;
    padding: 5px 15px;
    border-top: 1px solid rgba(255,255,255,0.1);
    border-bottom: 1px solid rgba(255,255,255,0.1);
}

#startScreen p.instructions {
    background-color: rgba(0,0,0,0.4);
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.5);
    max-width: min(600px, 90%);
    border-left: 3px solid #f44336;
    border-right: 3px solid #4CAF50;
    margin-bottom: 35px;
}

#startScreen p.instructions b {
    color: #ff5555;
    text-shadow: 0 0 5px rgba(255,0,0,0.3);
}

#startButton {
    background: linear-gradient(to bottom, #5cb85c, #449d44);
    font-size: 1.5rem;
    text-transform: uppercase;
    letter-spacing: 2px;
    padding: 15px 40px;
    border-radius: 50px;
    box-shadow: 
        0 6px 0 #2d662d,
        0 6px 10px rgba(0,0,0,0.5);
    position: relative;
    overflow: hidden;
}

#startButton:hover {
    background: linear-gradient(to bottom, #5cb85c, #3d8b3d);
    transform: translateY(2px);
    box-shadow: 
        0 4px 0 #2d662d,
        0 4px 6px rgba(0,0,0,0.5);
}

#startButton:active {
    transform: translateY(6px);
    box-shadow: 0 0 0 #2d662d;
}

#startButton::after {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: linear-gradient(to right, transparent, rgba(255,255,255,0.1), transparent);
    transform: rotate(45deg);
    animation: sheen 3s infinite;
}

#startScreen, #gameOver h1, #pauseScreen h1 {
    font-size: 48px;
    margin-bottom: 20px;
}

#startScreen p, #gameOver p, #pauseScreen p {
    font-size: 20px;
    margin-bottom: 30px;
    max-width: 80%;
}

#gameOver { display: none; }
#pauseScreen { display: none; }

#crosshair {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 20px;
    height: 20px;
    pointer-events: none;
    display: none;
    z-index: 5;
    transform: translate(-50%, -50%);
}

#crosshair::before, #crosshair::after {
    content: '';
    position: absolute;
    background-color: rgba(255, 255, 255, 0.8);
}

#crosshair::before {
    width: 100%;
    height: 2px;
    top: 50%;
    left: 0;
    transform: translateY(-50%);
}

#crosshair::after {
    width: 2px;
    height: 100%;
    top: 0;
    left: 50%;
    transform: translateX(-50%);
}

#touchControls {
    position: absolute;
    bottom: 30px;
    width: 100%;
    display: none;
    justify-content: space-between;
    padding: 0 20px;
    box-sizing: border-box;
    z-index: 5;
    pointer-events: none;
}

.joystick, #shootButtonTouch, #viewToggleTouchButton {
    width: 100px;
    height: 100px;
    background-color: rgba(255, 255, 255, 0.3);
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    color: white;
    font-size: 18px;
    user-select: none;
    touch-action: none;
    pointer-events: auto;
    position: relative;
}

.joystick-thumb {
    position: absolute;
    width: 40px;
    height: 40px;
    background-color: rgba(255, 255, 255, 0.5);
    border-radius: 50%;
    transform: translate(0, 0);
    transition: transform 0.05s linear;
}

#shootButtonTouch {
    width: 80px;
    height: 80px;
    background-color: rgba(255, 0, 0, 0.4);
}

#viewToggleTouchButton {
    width: 60px;
    height: 60px;
    background-color: rgba(156, 39, 176, 0.5);
    position: absolute;
    right: 20px;
    top: 20px;
}

#levelInfo {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
    font-size: 48px;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
    display: none;
    text-align: center;
    z-index: 5;
}

#damageOverlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(255, 0, 0, 0);
    pointer-events: none;
    z-index: 4;
    transition: background-color 0.5s;
}

#minimap {
    position: absolute;
    bottom: 20px;
    left: 20px;
    width: 150px;
    height: 150px;
    background-color: rgba(0, 0, 0, 0.5);
    border: 2px solid rgba(255, 255, 255, 0.5);
    border-radius: 50%;
    overflow: hidden;
    z-index: 5;
    display: none;
}

@media (max-width: 768px) and (pointer: coarse) {
    #touchControls {
        justify-content: space-around;
    }
    #ui { font-size: 18px; }
    #startScreen p br { display: none; }
    #startScreen p span#desktop-instructions { display: none; }
    #minimap {
        width: 100px;
        height: 100px;
    }
    #startScreen h1 {
        font-size: clamp(2.5rem, 8vw, 4rem);
    }
    #startButton {
        padding: 12px 30px;
        font-size: 1.2rem;
    }
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

@keyframes pulse {
    0% { text-shadow: 0 0 10px rgba(255,0,0,0.8), 0 0 20px rgba(255,0,0,0.5), 0 0 30px rgba(255,0,0,0.3); }
    100% { text-shadow: 0 0 15px rgba(255,0,0,0.9), 0 0 25px rgba(255,0,0,0.6), 0 0 35px rgba(255,0,0,0.4), 0 0 45px rgba(255,0,0,0.2); }
}

@keyframes sheen {
    0% { transform: translateX(-150%) rotate(45deg); }
    50% { transform: translateX(150%) rotate(45deg); }
    100% { transform: translateX(150%) rotate(45deg); }
}
    </style>
    
</head>
<body>
    <div id="startScreen" class="screen-overlay visible"> <h1>ZOMBIE SHOOTER</h1>
        <div class="branding">By Avuyile Mthembu | Vylex nexys</div>
        <p class="instructions">
            <span id="desktop-instructions">
                <b>Desktop:</b> Use <b>WASD</b> or <b>Arrow Keys</b> to move.<br>
                Use <b>Mouse</b> to aim and <b>Left Click</b> or <b>Space</b> to shoot.<br>
                Press <b>V</b> to toggle view (1st/3rd Person). Press <b>ESC</b> to pause.
            </span>
            <span id="mobile-instructions">
                <b>Mobile:</b> Use the <b>left joystick</b> to move.<br>
                Use the <b>right joystick</b> to aim.<br>
                Tap the red <b>SHOOT</b> button to fire.<br>
                Tap the purple <b>VIEW</b> button (top right) to toggle camera view.
            </span>
        </p>
        <button id="startButton">START GAME</button>
    </div>

    <div id="gameOver" class="screen-overlay">
        <h1>GAME OVER</h1>
        <div id="finalScore" style="color: white; font-size: 24px; margin-bottom: 20px;"></div>
        <button id="restartButtonGameOver">PLAY AGAIN</button>
    </div>

    <div id="pauseScreen" class="screen-overlay">
        <h1>PAUSED</h1>
        <p>Game paused. Take a break!</p>
        <button id="resumeButton">RESUME</button>
        <button id="viewToggleButton">TOGGLE VIEW</button>
        <button id="restartButtonPause">RESTART</button>
    </div>

    <div id="ui">
        <div>Score: <span id="score">0</span></div>
        <div>Level: <span id="level">1</span></div>
        <div>Health: <span id="health">100</span></div>
        <div>Zombies: <span id="enemies">0</span></div>
    </div>

    <div id="levelInfo"></div>
    <div id="crosshair"></div>
    <div id="damageOverlay"></div>
    <div id="minimap"></div>

    <div id="touchControls">
        <div id="moveJoystick" class="joystick">
            <div class="joystick-thumb"></div>
            <span>MOVE</span>
        </div>
        <div style="display: flex; align-items: center; pointer-events: none;">
             <div id="lookJoystick" class="joystick">
                <div class="joystick-thumb"></div>
                <span>LOOK</span>
            </div>
            <div id="shootButtonTouch" style="margin-left: 15px;">SHOOT</div>
        </div>
    </div>
    <div id="viewToggleTouchButton">VIEW</div>


    <canvas id="gameCanvas"></canvas>

    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/loaders/GLTFLoader.js"></script>
    <script>
        // Game variables
        let scene, camera, renderer, player, playerBody, bullets = [], enemies = [], particles = [];
        let score = 0, level = 1, health = 100, gameActive = false, isPaused = false;
        let clock = new THREE.Clock();
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        const playerSpeed = 8.0;
        let isShooting = false;
        let lastShootTime = 0;
        const shootCooldown = 300; // Fixed shoot cooldown in ms
        let enemiesKilled = 0;
        let totalEnemies = 5;
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        let audioContext;
        let soundEffects = {};
        let powerUps = [];
        let difficultyMultiplier = 1.0;
        let playerInvincible = false; // Note: This doesn't seem to be used? Consider removing or implementing.
        let thirdPersonView = false;
        let gameLoop;
        let zombieModels = [];
        let defaultWeaponModel = null;

        // Controls and Camera variables
        const mouseSensitivity = 0.002;
        const touchSensitivity = 0.01;
        const minPitch = -Math.PI / 2 + 0.1;
        const maxPitch = Math.PI / 2 - 0.1;
        let lookJoystickActive = false;
        let lookJoystickPosition = { x: 0, y: 0 };
        let moveJoystickActive = false;
        let moveJoystickPosition = { x: 0, y: 0 };

        // Map variables
        let minimapContext;
        let minimapSize = 150;
        let obstacles = [];

        // Initialize the game
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222233);
            scene.fog = new THREE.FogExp2(0x222233, 0.03);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('gameCanvas'),
                antialias: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            setupLighting();
            createEnvironment();
            createPlayer();
            initMinimap(); // Needs to happen after player for correct mobile size check
            preloadZombieModels();
            preloadDefaultWeaponModel();

            initAudio();
            spawnEnemies(totalEnemies); // Spawn initial enemies
            setupEventListeners();
            updateUI(); // Initial UI state

            if (isMobile) {
                document.getElementById('touchControls').style.display = 'flex';
            }
        }

        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffcc, 0.8);
            directionalLight.position.set(10, 20, 15);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
            const pointLight1 = new THREE.PointLight(0x6688ff, 1, 30);
            pointLight1.position.set(15, 5, 15);
            scene.add(pointLight1);
            const pointLight2 = new THREE.PointLight(0xff8866, 1, 30);
            pointLight2.position.set(-15, 5, -15);
            scene.add(pointLight2);
        }

        function createEnvironment() {
            const groundSize = 100;
            const groundTexture = createGroundTexture();
            const groundMaterial = new THREE.MeshStandardMaterial({
                map: groundTexture,
                roughness: 0.8,
                metalness: 0.2
            });
            const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize);
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.5;
            ground.receiveShadow = true;
            scene.add(ground);
            const gridHelper = new THREE.GridHelper(groundSize, 100, 0x000000, 0x111111);
            gridHelper.position.y = -0.49;
            scene.add(gridHelper);
            createWalls(groundSize);
            createObstacles();
        }

        function createGroundTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < 15000; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const size = Math.random() * 2;
                const alpha = Math.random() * 0.2;
                ctx.fillStyle = `rgba(0, 0, 0, ${alpha})`;
                ctx.fillRect(x, y, size, size);
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(4, 4);
            return texture;
        }

        function createPlayer() {
            player = new THREE.Group();
            player.position.set(0, 0.5, 0); // Player group center at feet level
            scene.add(player);

            // --- Player Visual Body (for 3rd person) ---
            playerBody = new THREE.Group();
            const bodyGeometry = new THREE.CylinderGeometry(0.4, 0.4, 1.8, 8);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x3366ff });
            const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
            bodyMesh.position.y = 0.9; // Center of cylinder at player's mid-height
            bodyMesh.castShadow = true;
            playerBody.add(bodyMesh);
            const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xffdbac });
            const headMesh = new THREE.Mesh(headGeometry, headMaterial);
            headMesh.position.y = 1.8 + 0.3; // Top of body + head radius
            headMesh.castShadow = true;
            playerBody.add(headMesh);
            const armGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.7, 8);
            const armMaterial = new THREE.MeshStandardMaterial({ color: 0x3366ff });
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.5, 1.2, 0);
            leftArm.rotation.z = Math.PI / 4;
            leftArm.castShadow = true;
            playerBody.add(leftArm);
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.5, 1.2, 0);
            rightArm.rotation.z = -Math.PI / 4;
            rightArm.castShadow = true;
            playerBody.add(rightArm);
            playerBody.visible = false; // Initially hidden (for 1st person)
            player.add(playerBody); // Add visual body to the main player group

            // --- Camera ---
            camera.position.set(0, 1.7, 0); // Camera at eye level relative to player group
            player.add(camera); // Attach camera to player group

            // --- Weapon Holder (for 1st person view) ---
            const weaponHolder = new THREE.Group();
            weaponHolder.position.set(0.3, -0.3, -0.5); // Position relative to camera
            camera.add(weaponHolder); // Attach to camera
            weaponHolder.name = "weaponHolder";

            // Add the visual representation of the single weapon immediately
            const defaultWeaponVisual = createDefaultWeapon();
            weaponHolder.add(defaultWeaponVisual);
        }


        function createDefaultWeapon() {
            // Re-using the pistol visual as the default
            const weaponGroup = new THREE.Group();
            const gunGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.3);
            const gunMaterial = new THREE.MeshStandardMaterial({ color: 0x111111 });
            const gun = new THREE.Mesh(gunGeometry, gunMaterial);
            gun.position.z = -0.15;
            weaponGroup.add(gun);
            const barrelGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.3, 8);
            const barrel = new THREE.Mesh(barrelGeometry, gunMaterial);
            barrel.rotation.x = Math.PI / 2;
            barrel.position.z = -0.3;
            weaponGroup.add(barrel);
            const handleGeometry = new THREE.BoxGeometry(0.1, 0.15, 0.1);
            const handle = new THREE.Mesh(handleGeometry, gunMaterial);
            handle.position.y = -0.125;
            weaponGroup.add(handle);
            return weaponGroup;
        }

        function preloadZombieModels() {
            for (let i = 0; i < 3; i++) {
                const zombieModel = createBasicZombieModel(i);
                zombieModels.push(zombieModel);
            }
        }

        function createBasicZombieModel(type) {
            const zombie = new THREE.Group();
            let bodyColor, headColor;
            switch(type) {
                case 0: bodyColor = 0x538c50; headColor = 0x6ea86a; break; // Regular
                case 1: bodyColor = 0x8c5050; headColor = 0xa86a6a; break; // Fast
                case 2: bodyColor = 0x50618c; headColor = 0x6a7ba8; break; // Tank
            }
            const bodyHeight = 1.8;
            const headRadius = 0.3;
            const bodyGeometry = new THREE.CylinderGeometry(0.4, 0.4, bodyHeight, 8);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: bodyColor, roughness: 0.9, metalness: 0.1 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = bodyHeight / 2; // Center body at mid-height
            body.castShadow = true;
            zombie.add(body);
            const headGeometry = new THREE.SphereGeometry(headRadius, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({ color: headColor, roughness: 0.9, metalness: 0.1 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = bodyHeight + headRadius; // Top of body + head radius
            head.castShadow = true;
            zombie.add(head);
            const eyeGeometry = new THREE.SphereGeometry(0.06, 8, 8);
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.15, head.position.y + 0.05, 0.2); // Relative to head position
            zombie.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.15, head.position.y + 0.05, 0.2); // Relative to head position
            zombie.add(rightEye);
            const armGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.7, 8);
            const armMaterial = new THREE.MeshStandardMaterial({ color: bodyColor });
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.name = 'leftArm';
            leftArm.position.set(-0.5, bodyHeight * 0.7, 0); // Adjusted arm position
            leftArm.rotation.z = Math.PI / 2.5;
            leftArm.castShadow = true;
            zombie.add(leftArm);
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.name = 'rightArm';
            rightArm.position.set(0.5, bodyHeight * 0.7, 0); // Adjusted arm position
            rightArm.rotation.z = -Math.PI / 2.5;
            rightArm.castShadow = true;
            zombie.add(rightArm);
            zombie.userData = { walkTime: Math.random() * Math.PI * 2, walkSpeed: 2 + Math.random() * 2 };
            // Set zombie group position at feet level (0 in y)
            zombie.position.y = 0;
            return zombie;
        }


        function preloadDefaultWeaponModel() {
            // Just creates the basic visual, no need for complex loading if using basic shapes
            defaultWeaponModel = createDefaultWeapon();
            // NOTE: If using GLTFLoader, you'd load the single model here.
        }

        function initMinimap() {
            const minimapElement = document.getElementById('minimap');
            while (minimapElement.firstChild) {
                minimapElement.removeChild(minimapElement.firstChild);
            }
            const canvas = document.createElement('canvas');
            minimapSize = isMobile ? 100 : 150; // Use correct size
            canvas.width = minimapSize;
            canvas.height = minimapSize;
            minimapElement.style.width = `${minimapSize}px`; // Ensure container size matches
            minimapElement.style.height = `${minimapSize}px`;
            minimapElement.appendChild(canvas);
            minimapContext = canvas.getContext('2d');
        }


        function drawMinimap() {
            if (!minimapContext || !player) return;

            minimapContext.clearRect(0, 0, minimapSize, minimapSize);
            minimapContext.fillStyle = 'rgba(0, 0, 0, 0.5)';
            minimapContext.fillRect(0, 0, minimapSize, minimapSize);

            const mapScale = minimapSize / 100; // Scale relative to game world size (100x100)
            const centerX = minimapSize / 2;
            const centerY = minimapSize / 2;

            // Calculate player position relative to the map center for drawing
            const playerMapX = centerX - player.position.x * mapScale;
            const playerMapY = centerY - player.position.z * mapScale; // Use Z for Y on map

            // --- Draw elements relative to the player's map position ---

             // Draw obstacles first (background elements)
            minimapContext.fillStyle = '#888888';
            obstacles.forEach(obstacle => {
                const obsScale = obstacle.scale || {x:1, z:1}; // Handle groups without explicit scale
                const obsMapX = playerMapX + obstacle.position.x * mapScale;
                const obsMapZ = playerMapY + obstacle.position.z * mapScale; // Use Z for Y on map

                // Draw if within minimap bounds (approx)
                 if (obsMapX > -obsScale.x*mapScale && obsMapX < minimapSize && obsMapZ > -obsScale.z*mapScale && obsMapZ < minimapSize) {
                    minimapContext.fillRect(
                        obsMapX - (obsScale.x * mapScale / 2),
                        obsMapZ - (obsScale.z * mapScale / 2), // Use Z for Y
                        obsScale.x * mapScale,
                        obsScale.z * mapScale  // Use Z for height
                    );
                }
            });

             // Draw powerups
            powerUps.forEach(powerUp => {
                 if (powerUp.userData.type === 'health') {
                     minimapContext.fillStyle = '#00ff00'; // Green for health
                     const puMapX = playerMapX + powerUp.position.x * mapScale;
                     const puMapZ = playerMapY + powerUp.position.z * mapScale;
                     // Draw if within minimap bounds
                     if (puMapX > -2 && puMapX < minimapSize + 2 && puMapZ > -2 && puMapZ < minimapSize + 2) {
                        minimapContext.beginPath();
                        minimapContext.arc(puMapX, puMapZ, 2, 0, Math.PI * 2);
                        minimapContext.fill();
                     }
                 }
            });

            // Draw enemies
            minimapContext.fillStyle = '#ff0000';
            enemies.forEach(enemy => {
                const enemyMapX = playerMapX + enemy.position.x * mapScale;
                const enemyMapZ = playerMapY + enemy.position.z * mapScale; // Use Z for Y
                 // Draw if within minimap bounds
                 if (enemyMapX > -2 && enemyMapX < minimapSize + 2 && enemyMapZ > -2 && enemyMapZ < minimapSize + 2) {
                    minimapContext.beginPath();
                    minimapContext.arc(enemyMapX, enemyMapZ, 2, 0, Math.PI * 2);
                    minimapContext.fill();
                }
            });

            // --- Draw Player centered ---
            minimapContext.fillStyle = '#3366ff';
            minimapContext.beginPath();
            minimapContext.arc(centerX, centerY, 3, 0, Math.PI * 2); // Player always at center
            minimapContext.fill();

            // Draw player direction indicator
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(player.quaternion); // Use player's rotation
            minimapContext.strokeStyle = '#3366ff';
            minimapContext.lineWidth = 2;
            minimapContext.beginPath();
            minimapContext.moveTo(centerX, centerY);
            // Draw line pointing in player's forward direction (map Z is negative world Z)
            minimapContext.lineTo(centerX + direction.x * 10, centerY + direction.z * 10); // Scale line length
            minimapContext.stroke();
        }


        function initAudio() {
            try {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                audioContext = new AudioContext();
                // Resume context if suspended (often needed after user interaction)
                if (audioContext.state === 'suspended') {
                    const resume = () => {
                        audioContext.resume();
                        document.body.removeEventListener('click', resume);
                        document.body.removeEventListener('touchstart', resume);
                    };
                    document.body.addEventListener('click', resume);
                    document.body.addEventListener('touchstart', resume);
                }

                soundEffects = {
                    shoot: createSound([440, 220, 0], 0.2, 'sawtooth'),
                    hit: createSound([440, 220], 0.2, 'sawtooth'),
                    explode: createSound([110, 55], 0.5, 'sawtooth'),
                    powerUp: createSound([523.25, 659.25, 783.99], 0.3, 'sine'),
                    zombie: createSound([77, 65], 0.4, 'sawtooth'),
                    pain: createSound([330, 220], 0.3, 'sawtooth')
                };
            } catch (e) {
                console.warn('Web Audio API is not supported:', e);
                audioContext = null;
                soundEffects = { // Dummy sounds
                    shoot: { play: () => {} }, hit: { play: () => {} },
                    explode: { play: () => {} }, powerUp: { play: () => {} },
                    zombie: { play: () => {} }, pain: { play: () => {} }
                };
            }
        }

        function createSound(frequencies, duration, type) {
            return {
                play: function(volume = 1.0) {
                    if (!audioContext || audioContext.state !== 'running') return; // Don't play if not ready

                    const gainNode = audioContext.createGain();
                    gainNode.gain.setValueAtTime(volume, audioContext.currentTime); // Set volume immediately
                    gainNode.connect(audioContext.destination);

                    frequencies.forEach((freq, index) => {
                        if (freq <= 0) return; // Skip zero/negative frequencies
                        const oscillator = audioContext.createOscillator();
                        oscillator.type = type;
                        oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);

                        const oscGain = audioContext.createGain();
                        // Start full volume and fade out
                        oscGain.gain.setValueAtTime(1.0 / frequencies.length, audioContext.currentTime);
                        oscGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);

                        oscillator.connect(oscGain);
                        oscGain.connect(gainNode);

                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + duration);
                    });
                }
            };
        }

        function createWalls(size) {
            const wallHeight = 5;
            const wallThickness = 1;
            const halfSize = size / 2;
            const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x777777, roughness: 0.8, metalness: 0.2 });

            // North Wall
            const northWall = createWallWithTexture(size, wallHeight, wallThickness, wallMaterial.clone());
            northWall.position.set(0, wallHeight / 2 - 0.5, -halfSize);
            northWall.castShadow = true; northWall.receiveShadow = true; scene.add(northWall);
             obstacles.push(northWall); // Add walls to obstacles for collision

            // South Wall
            const southWall = createWallWithTexture(size, wallHeight, wallThickness, wallMaterial.clone());
            southWall.position.set(0, wallHeight / 2 - 0.5, halfSize);
            southWall.castShadow = true; southWall.receiveShadow = true; scene.add(southWall);
             obstacles.push(southWall);

            // East Wall
            const eastWall = createWallWithTexture(wallThickness, wallHeight, size, wallMaterial.clone()); // Adjusted geometry for side walls
            // eastWall.rotation.y = Math.PI / 2; // No rotation needed if geometry is adjusted
            eastWall.position.set(halfSize, wallHeight / 2 - 0.5, 0);
            eastWall.castShadow = true; eastWall.receiveShadow = true; scene.add(eastWall);
             obstacles.push(eastWall);

            // West Wall
            const westWall = createWallWithTexture(wallThickness, wallHeight, size, wallMaterial.clone()); // Adjusted geometry for side walls
            // westWall.rotation.y = Math.PI / 2; // No rotation needed
            westWall.position.set(-halfSize, wallHeight / 2 - 0.5, 0);
            westWall.castShadow = true; westWall.receiveShadow = true; scene.add(westWall);
             obstacles.push(westWall);
        }

        function createWallWithTexture(width, height, depth, material) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const texture = createWallTexture(width, depth); // Pass dimensions for texture scaling
            material.map = texture;
             // Set scale explicitly for collision detection consistency
            const wallMesh = new THREE.Mesh(geometry, material);
            wallMesh.scale.set(width, height, depth); // Use actual dimensions for scale
            return wallMesh;
        }

        function createWallTexture(width, depth) {
            const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 512; const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#777777'; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.fillStyle = '#666666';
            // Simplified brick pattern
            const brickWidth = 64; const brickHeight = 32;
            for (let y = 0; y < canvas.height; y += brickHeight) {
                 const offsetX = (y / brickHeight) % 2 === 0 ? 0 : brickWidth / 2;
                 for (let x = -offsetX; x < canvas.width; x += brickWidth) {
                     ctx.fillRect(x, y, brickWidth - 4, brickHeight - 4); // Add gaps
                 }
            }
            ctx.strokeStyle = '#555555'; ctx.lineWidth = 2; // Thicker mortar lines
            for (let y = 0; y < canvas.height; y += brickHeight) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke(); }
            for (let y = 0; y < canvas.height; y += brickHeight) {
                const offsetX = (y / brickHeight) % 2 === 0 ? 0 : brickWidth / 2;
                 for (let x = -offsetX; x < canvas.width; x += brickWidth) {
                     ctx.beginPath(); ctx.moveTo(x + brickWidth / 2, y); ctx.lineTo(x + brickWidth / 2, y + brickHeight); ctx.stroke();
                 }
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping; texture.wrapT = THREE.RepeatWrapping;
            // Adjust repeat based on wall dimensions for better look
            texture.repeat.set(Math.max(1, width / 5), Math.max(1, depth / 5)); // Rough estimate
            return texture;
        }

        function createObstacles() {
            obstacles = []; // Clear existing obstacles before creating new ones
            const numObstacles = 15;
            const groundSize = 80; // Area within walls to place obstacles
            const playerClearance = 15; // Don't spawn too close to player start

            for (let i = 0; i < numObstacles; i++) {
                const size = 1 + Math.random() * 3;
                const height = 1 + Math.random() * 3;
                const obstacle = createObstacleMesh(size, height, i); // Get the mesh/group

                let x, z;
                let validPosition = false;
                let attempts = 0; // Prevent infinite loops
                while (!validPosition && attempts < 100) {
                    x = (Math.random() - 0.5) * groundSize;
                    z = (Math.random() - 0.5) * groundSize;
                    const distFromPlayer = Math.sqrt(x*x + z*z); // Distance from center (0,0)

                    validPosition = distFromPlayer > playerClearance; // Check player clearance first

                    if (validPosition) {
                        // Check collision with existing obstacles
                        for (const otherObstacle of obstacles) {
                            if (!otherObstacle.scale) continue; // Skip if scale isn't set (e.g., walls might not have it yet if called early)
                            const dx = x - otherObstacle.position.x;
                            const dz = z - otherObstacle.position.z;
                            const distFromObstacle = Math.sqrt(dx*dx + dz*dz);
                            // Use the larger dimension for clearance check
                            const thisClearance = Math.max(obstacle.scale.x, obstacle.scale.z) / 2;
                            const otherClearance = Math.max(otherObstacle.scale.x, otherObstacle.scale.z) / 2;
                            const minSeparation = thisClearance + otherClearance + 1.0; // Add buffer

                            if (distFromObstacle < minSeparation) {
                                validPosition = false;
                                break; // No need to check further obstacles
                            }
                        }
                    }
                    attempts++;
                }

                if (validPosition) {
                    obstacle.position.set(x, obstacle.scale.y / 2 - 0.5, z); // Position based on calculated scale height
                    obstacle.castShadow = true;
                    obstacle.receiveShadow = true;
                    scene.add(obstacle);
                    obstacles.push(obstacle); // Add to obstacles array *after* position is valid
                } else {
                     console.warn("Could not find valid position for obstacle", i);
                     // Optionally discard the created obstacle mesh here if needed
                }
            }
        }


        function createObstacleMesh(size, height, index) { // Renamed to clarify it returns the mesh/group
            let geometry, material, obstacle;
            let calculatedScale = new THREE.Vector3(size, height, size); // Default scale

            switch (index % 5) {
                case 0: // Crate
                    geometry = new THREE.BoxGeometry(1, 1, 1); // Unit size geometry
                    material = new THREE.MeshStandardMaterial({ color: 0x8b4513, roughness: 0.8, metalness: 0.2 });
                    obstacle = new THREE.Mesh(geometry, material);
                    calculatedScale.set(size, height, size);
                    break;
                case 1: // Barrel
                    geometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 12); // Unit size geometry
                    material = new THREE.MeshStandardMaterial({ color: 0x880000, roughness: 0.7, metalness: 0.3 });
                    obstacle = new THREE.Mesh(geometry, material);
                    calculatedScale.set(size, height, size); // Scale x and z for width/depth
                    break;
                case 2: // Rock
                    geometry = new THREE.DodecahedronGeometry(0.5, 1); // Unit size geometry (approx)
                    material = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.9, metalness: 0.1 });
                    obstacle = new THREE.Mesh(geometry, material);
                    calculatedScale.set(size, size, size); // Rocks are roughly spherical
                    break;
                case 3: // Car wreck
                    obstacle = new THREE.Group();
                    const carBaseSize = new THREE.Vector3(2, 1, 1); // Base proportions for unit car
                    calculatedScale.set(size * carBaseSize.x, height, size * carBaseSize.z); // Scale based on input size/height

                    const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.8, metalness: 0.5 });
                    const bodyGeometry = new THREE.BoxGeometry(carBaseSize.x, carBaseSize.y * 0.7, carBaseSize.z);
                    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    body.castShadow = true; body.receiveShadow = true;
                    obstacle.add(body);

                    const topGeometry = new THREE.BoxGeometry(carBaseSize.x*0.5, carBaseSize.y * 0.5, carBaseSize.z * 0.8);
                    const top = new THREE.Mesh(topGeometry, bodyMaterial);
                    top.position.set(carBaseSize.x * 0.25, carBaseSize.y * 0.35, 0);
                    top.castShadow = true; top.receiveShadow = true;
                    obstacle.add(top);

                    const wheelRadius = carBaseSize.y * 0.25; // Scaled wheel size
                    const wheelWidth = carBaseSize.z * 0.2;
                    const wheelGeometry = new THREE.CylinderGeometry(wheelRadius, wheelRadius, wheelWidth, 8);
                    const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.9, metalness: 0.1 });
                    // Position wheels relative to unit size
                    [ [0.35, -0.25, 0.45], [0.35, -0.25, -0.45], [-0.35, -0.25, 0.45], [-0.35, -0.25, -0.45] ].forEach(pos => {
                        const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                        wheel.rotation.x = Math.PI / 2; // Rotate to stand upright
                        wheel.position.set(carBaseSize.x * pos[0], carBaseSize.y * pos[1], carBaseSize.z * pos[2]);
                        wheel.castShadow = true; wheel.receiveShadow = true;
                        obstacle.add(wheel);
                    });
                    break;
                case 4: // Tree
                    obstacle = new THREE.Group();
                    const trunkHeight = height;
                    const foliageHeight = height * 1.5;
                    const trunkRadius = size * 0.2;
                    const foliageRadius = size;
                     calculatedScale.set(foliageRadius * 2, trunkHeight + foliageHeight, foliageRadius * 2); // Overall bounding box

                    const trunkGeometry = new THREE.CylinderGeometry(trunkRadius * 0.8, trunkRadius, trunkHeight, 8);
                    const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513, roughness: 0.9, metalness: 0.1 });
                    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                    trunk.position.y = 0; // Base of trunk at 0
                    trunk.castShadow = true; trunk.receiveShadow = true;
                    obstacle.add(trunk);

                    const foliageGeometry = new THREE.ConeGeometry(foliageRadius, foliageHeight, 8);
                    const foliageMaterial = new THREE.MeshStandardMaterial({ color: 0x006400, roughness: 1.0, metalness: 0.0 });
                    const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                    foliage.position.y = trunkHeight + foliageHeight / 2; // Position foliage above trunk
                    foliage.castShadow = true; foliage.receiveShadow = true;
                    obstacle.add(foliage);
                    break;
                default: // Fallback: Simple Box
                    geometry = new THREE.BoxGeometry(1, 1, 1); // Unit size
                    material = new THREE.MeshStandardMaterial({ color: new THREE.Color(0.3 + Math.random() * 0.4, 0.3 + Math.random() * 0.4, 0.3 + Math.random() * 0.4), roughness: 0.7, metalness: 0.2 });
                    obstacle = new THREE.Mesh(geometry, material);
                    calculatedScale.set(size, height, size);
            }

            // Apply the final calculated scale to the mesh or group
             if (obstacle) {
                obstacle.scale.copy(calculatedScale);
                 // Ensure children inherit transformations correctly for shadows etc.
                 obstacle.traverse(child => {
                     child.castShadow = true;
                     child.receiveShadow = true;
                 });
             } else {
                 // Create a dummy obstacle if something went wrong, to avoid errors later
                 obstacle = new THREE.Group();
                 obstacle.scale.set(1, 1, 1);
                 console.error("Failed to create obstacle type:", index % 5);
             }


            return obstacle;
        }


        function spawnEnemies(count) {
            const groundSize = 80; // Area within walls
             const playerSafeZone = 20; // Don't spawn right next to player

            for (let i = 0; i < count; i++) {
                const type = Math.random() < 0.7 ? 0 : (Math.random() < 0.7 ? 1 : 2); // 70% normal, 21% fast, 9% tank
                const enemyModel = createZombie(type); // Creates the model with correct user data

                let x, z;
                let validPosition = false;
                let attempts = 0;
                while (!validPosition && attempts < 100) {
                    x = (Math.random() - 0.5) * groundSize;
                    z = (Math.random() - 0.5) * groundSize;
                    const distFromPlayer = player ? Math.sqrt(Math.pow(x - player.position.x, 2) + Math.pow(z - player.position.z, 2)) : playerSafeZone + 1; // Distance from current player pos or center

                    validPosition = distFromPlayer > playerSafeZone; // Check player clearance

                    if (validPosition) {
                        // Check collision with obstacles
                        for (const obstacle of obstacles) {
                            if (!obstacle.scale) continue;
                            const dx = x - obstacle.position.x;
                            const dz = z - obstacle.position.z;
                            const distFromObstacle = Math.sqrt(dx*dx + dz*dz);
                            const obstacleClearance = Math.max(obstacle.scale.x, obstacle.scale.z) / 2;
                            const enemyClearance = (enemyModel.userData.size || 1.0) * 0.5; // Use zombie size
                            const minSeparation = obstacleClearance + enemyClearance + 0.5; // Add buffer

                            if (distFromObstacle < minSeparation) {
                                validPosition = false;
                                break;
                            }
                        }
                    }
                     // Check collision with other newly spawned enemies in this batch (less critical, but good)
                     if (validPosition) {
                        for (const existingEnemy of enemies) {
                             const dx = x - existingEnemy.position.x;
                             const dz = z - existingEnemy.position.z;
                             const dist = Math.sqrt(dx * dx + dz * dz);
                             if (dist < (enemyModel.userData.size + existingEnemy.userData.size) * 0.6) { // Check against other enemies too
                                 validPosition = false;
                                 break;
                             }
                        }
                     }
                    attempts++;
                }

                if(validPosition) {
                    enemyModel.position.set(x, 0, z); // Set position at feet level
                    scene.add(enemyModel);
                    enemies.push(enemyModel);
                    enemyModel.rotation.y = Math.random() * Math.PI * 2; // Random initial facing direction
                } else {
                     console.warn("Could not find valid position for enemy", i);
                     // Optional: Decrement 'count' or handle the failure if necessary
                }
            }
            updateUI(); // Update enemy count on UI
        }


        function createZombie(type) {
            // Clone the preloaded model to avoid modifying the original
            const zombie = zombieModels[type].clone(true); // Deep clone

            let healthVal, speedVal, damageVal, sizeVal, attackCd, soundCd;
            switch(type) {
                case 0: healthVal=100; speedVal=0.03; damageVal=5; sizeVal=1.0; attackCd=1000; soundCd=5000; break; // Normal
                case 1: healthVal=70;  speedVal=0.05; damageVal=3; sizeVal=0.9; attackCd=800; soundCd=4000; break; // Fast
                case 2: healthVal=200; speedVal=0.02; damageVal=10; sizeVal=1.3; attackCd=1500; soundCd=6000; break; // Tank
            }

            // Apply scaling BEFORE setting userData if size affects calculations
            if (sizeVal !== 1.0) {
                zombie.scale.setScalar(sizeVal);
            }

            zombie.userData = {
                health: healthVal,
                 // Adjust speed based on level and difficulty more significantly
                speed: (speedVal * (1 + level * 0.05)) * difficultyMultiplier,
                damage: damageVal * difficultyMultiplier,
                type: type === 1 ? 'fast' : (type === 2 ? 'tank' : 'normal'),
                size: sizeVal, // Store the base size multiplier
                lastAttackTime: 0,
                attackCooldown: attackCd,
                lastSoundTime: 0,
                soundCooldown: soundCd + Math.random() * soundCd * 0.5, // Randomize sound cooldown
                walkTime: Math.random() * Math.PI * 2, // Initialize animation properties here
                walkSpeed: 2 + Math.random() * 2
            };

            // Ensure visibility and correct starting state
            zombie.visible = true;
            zombie.position.y = 0; // Ensure feet are at y=0

            return zombie;
        }


        function spawnPowerUp(position) {
            // Only spawn health power-ups now
            const type = 'health';
            const color = 0x00ff00;
            const size = 0.4;

            const powerUpGroup = new THREE.Group();
            const baseGeometry = new THREE.BoxGeometry(size, size, size);
            const baseMaterial = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.4,
                metalness: 0.8,
                emissive: color,
                emissiveIntensity: 0.3,
                transparent: true, // Enable transparency for potential fading
                opacity: 1.0
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.castShadow = true; // Powerups can cast subtle shadows
            powerUpGroup.add(base);

            // Add a subtle light source
            const light = new THREE.PointLight(color, 0.7, 3);
            powerUpGroup.add(light);

            // Health icon (simple cross on the front face)
            const crossMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const verticalPartGeo = new THREE.BoxGeometry(size * 0.2, size * 0.7, size * 0.1); // Thin cross part
            const verticalMesh = new THREE.Mesh(verticalPartGeo, crossMaterial);
            verticalMesh.position.z = size * 0.51; // Position slightly in front of the box face
            powerUpGroup.add(verticalMesh);
            const horizontalPartGeo = new THREE.BoxGeometry(size * 0.7, size * 0.2, size * 0.1); // Thin cross part
            const horizontalMesh = new THREE.Mesh(horizontalPartGeo, crossMaterial);
            horizontalMesh.position.z = size * 0.51; // Position slightly in front
            powerUpGroup.add(horizontalMesh);

            // Determine spawn position
            let spawnPos = new THREE.Vector3();
            if (position) {
                spawnPos.copy(position);
                spawnPos.y = 0.5; // Ensure consistent height
            } else {
                // Find a random valid position if none provided
                let x, z;
                const groundSize = 80;
                const minPlayerDist = 5;
                const maxPlayerDist = 30;
                let valid = false;
                let attempts = 0;
                 while (!valid && attempts < 50) {
                     x = (Math.random() - 0.5) * groundSize;
                     z = (Math.random() - 0.5) * groundSize;
                     const distPlayer = player ? player.position.distanceTo(new THREE.Vector3(x, 0, z)) : minPlayerDist + 1;

                     if (distPlayer > minPlayerDist && distPlayer < maxPlayerDist) {
                         // Optional: Check collision with obstacles
                         valid = true; // Assume valid for now if distance is okay
                     }
                     attempts++;
                 }
                 if (valid) {
                     spawnPos.set(x, 0.5, z);
                 } else {
                     // Fallback: spawn near player origin if random fails
                     spawnPos.set((Math.random()-0.5)*5, 0.5, (Math.random()-0.5)*5);
                 }
            }
            powerUpGroup.position.copy(spawnPos);


            powerUpGroup.userData = {
                type: type,
                created: Date.now(),
                rotationSpeed: 0.02,
                hoverBaseHeight: 0.5, // Store base height
                hoverAmplitude: 0.2, // How much it bobs
                hoverFrequency: 0.003 // Speed of bobbing
            };
            scene.add(powerUpGroup);
            powerUps.push(powerUpGroup);
            return powerUpGroup;
        }

        function collectPowerUp(powerUp) {
            if (powerUp.userData.type === 'health') {
                health = Math.min(health + 50, 100); // Heal up to max 100
                playSound('powerUp');
                // Use the powerup's position for the effect
                createExplosion(powerUp.position.clone(), new THREE.Color(0x00ff00), 15);
                updateUI();
            }
            // No other power-up types currently
        }


        function setupEventListeners() {
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);

            const canvas = document.getElementById('gameCanvas');
            canvas.addEventListener('click', () => {
                // Request pointer lock only if game is active and not paused
                if (gameActive && !isPaused) {
                     // Resume audio context on user interaction
                     if (audioContext && audioContext.state === 'suspended') {
                         audioContext.resume();
                     }
                     canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock;
                     canvas.requestPointerLock();
                }
            });

            document.addEventListener('pointerlockchange', handlePointerLockChange, false);
            document.addEventListener('mozpointerlockchange', handlePointerLockChange, false);
            document.addEventListener('pointerlockerror', handlePointerLockError, false);
            document.addEventListener('mozpointerlockerror', handlePointerLockError, false);

            // Use mousedown/mouseup for continuous shooting
            document.addEventListener('mousedown', onMouseDown, false);
            document.addEventListener('mouseup', onMouseUp, false);
            document.addEventListener('mousemove', onMouseMove, false);

            // Keydown for single-press actions (toggle view, pause, space initial press)
            document.addEventListener('keydown', function(event) {
                if (!gameActive) return; // Ignore if game not running

                if (event.code === 'KeyV' && !isPaused) {
                     toggleView();
                } else if (event.code === 'Escape') {
                     togglePause();
                } else if (event.code === 'Space' && !isPaused && !isShooting) {
                    // Set isShooting flag on initial press for hold-to-shoot
                    isShooting = true;
                }
            });

            // Keyup for stopping continuous actions (shooting)
            document.addEventListener('keyup', function(event) {
                if (event.code === 'Space') {
                    isShooting = false;
                }
            });

            // Touch Controls Setup
            if (isMobile) {
                 setupTouchControls();
            }

            // Button Listeners
            document.getElementById('startButton').addEventListener('click', startGame);
            document.getElementById('restartButtonGameOver').addEventListener('click', restartGame);
            document.getElementById('restartButtonPause').addEventListener('click', restartGame);
            document.getElementById('resumeButton').addEventListener('click', togglePause);
            document.getElementById('viewToggleButton').addEventListener('click', toggleView); // Button on pause menu
            document.getElementById('viewToggleTouchButton').addEventListener('touchstart', function(e) {
                e.preventDefault();
                if (gameActive && !isPaused) toggleView();
            }, { passive: false }); // Use touchstart for immediate response
        }


        function toggleView() {
            thirdPersonView = !thirdPersonView;
            const weaponHolder = camera.getObjectByName("weaponHolder");

            if (thirdPersonView) {
                // Move camera behind and slightly above
                camera.position.set(0, 2.5, 5); // Adjust Y and Z for better view
                // Ensure the camera looks slightly down towards the player model center
                const lookAtTarget = player.position.clone().add(new THREE.Vector3(0, 1.0, 0)); // Look at player's torso height
                camera.lookAt(lookAtTarget);
                playerBody.visible = true; // Show player model
                if (weaponHolder) weaponHolder.visible = false; // Hide 1st person weapon
                 if (document.getElementById('crosshair')) document.getElementById('crosshair').style.display = 'none'; // Hide crosshair in 3rd person

            } else {
                // Reset camera to 1st person position (relative to player group)
                camera.position.set(0, 1.7, 0);
                camera.rotation.set(0, 0, 0); // Reset camera rotation relative to player
                playerBody.visible = false; // Hide player model
                if (weaponHolder) weaponHolder.visible = true; // Show 1st person weapon
                 // Show crosshair if pointer is locked
                 if (document.pointerLockElement === renderer.domElement || document.mozPointerLockElement === renderer.domElement) {
                     if (document.getElementById('crosshair')) document.getElementById('crosshair').style.display = 'block';
                 }
            }
        }


        function setupTouchControls() {
            const moveJoystick = document.getElementById('moveJoystick');
            const lookJoystick = document.getElementById('lookJoystick');
            const shootButton = document.getElementById('shootButtonTouch');
            const moveThumb = moveJoystick.querySelector('.joystick-thumb');
            const lookThumb = lookJoystick.querySelector('.joystick-thumb');
            let moveTouchId = null;
            let lookTouchId = null;

             // Helper to find the correct touch within the event
             const findTouch = (event, targetId) => {
                 for (let i = 0; i < event.changedTouches.length; i++) {
                     if (event.changedTouches[i].identifier === targetId) {
                         return event.changedTouches[i];
                     }
                 }
                 return null; // Should not happen if logic is correct
             };


            moveJoystick.addEventListener('touchstart', (e) => {
                 e.preventDefault();
                 if (!gameActive || isPaused || moveTouchId !== null) return;
                 moveTouchId = e.changedTouches[0].identifier; // Store the ID of the touch that started on this joystick
                 moveJoystickActive = true;
                 handleJoystickMove(e.changedTouches[0], 'move', moveThumb); // Use the specific touch
            }, { passive: false });

            moveJoystick.addEventListener('touchmove', (e) => {
                 e.preventDefault();
                 if (!gameActive || isPaused || moveTouchId === null) return;
                 const touch = findTouch(e, moveTouchId); // Find the specific touch that is moving
                 if (touch) {
                     handleJoystickMove(touch, 'move', moveThumb);
                 }
            }, { passive: false });

             const moveEndHandler = (e) => {
                 e.preventDefault();
                 if (moveTouchId === null) return;
                 const touch = findTouch(e, moveTouchId);
                 if (touch) { // Only end if the correct touch is lifted
                     handleJoystickEnd('move', moveThumb);
                     moveTouchId = null; // Release the touch ID lock
                 }
             };
            moveJoystick.addEventListener('touchend', moveEndHandler, { passive: false });
            moveJoystick.addEventListener('touchcancel', moveEndHandler, { passive: false }); // Handle cancel as end


            // --- Look Joystick (Similar logic with lookTouchId) ---
            lookJoystick.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (!gameActive || isPaused || lookTouchId !== null) return;
                 lookTouchId = e.changedTouches[0].identifier;
                lookJoystickActive = true;
                handleJoystickMove(e.changedTouches[0], 'look', lookThumb);
            }, { passive: false });

            lookJoystick.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!gameActive || isPaused || lookTouchId === null) return;
                const touch = findTouch(e, lookTouchId);
                 if (touch) {
                     handleJoystickMove(touch, 'look', lookThumb);
                 }
            }, { passive: false });

             const lookEndHandler = (e) => {
                 e.preventDefault();
                 if (lookTouchId === null) return;
                 const touch = findTouch(e, lookTouchId);
                 if (touch) {
                     handleJoystickEnd('look', lookThumb);
                     lookTouchId = null;
                 }
             };
            lookJoystick.addEventListener('touchend', lookEndHandler, { passive: false });
            lookJoystick.addEventListener('touchcancel', lookEndHandler, { passive: false });


            // --- Shoot Button ---
            shootButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                 if(gameActive && !isPaused) {
                    isShooting = true;
                    shootButton.style.backgroundColor = 'rgba(255, 0, 0, 0.7)'; // Visual feedback
                 }
            }, { passive: false });

            shootButton.addEventListener('touchend', (e) => {
                 e.preventDefault();
                 isShooting = false;
                 shootButton.style.backgroundColor = 'rgba(255, 0, 0, 0.4)'; // Reset visual feedback
            }, { passive: false });
            shootButton.addEventListener('touchcancel', (e) => { // Handle cancel the same as end
                 e.preventDefault();
                 isShooting = false;
                 shootButton.style.backgroundColor = 'rgba(255, 0, 0, 0.4)';
            }, { passive: false });
        }


        // Takes a specific touch object, not the whole event
        function handleJoystickMove(touch, type, thumbElement) {
            if (!touch || !gameActive || isPaused) return; // Check touch object

            if ((type === 'move' && !moveJoystickActive) || (type === 'look' && !lookJoystickActive)) return;

            const joystickElement = document.getElementById(type === 'move' ? 'moveJoystick' : 'lookJoystick');
            const rect = joystickElement.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const maxDist = rect.width / 2 - (thumbElement.offsetWidth / 2); // Max distance thumb center can move
            let rawX = touch.clientX - centerX;
            let rawY = touch.clientY - centerY;
            const dist = Math.sqrt(rawX * rawX + rawY * rawY);
            let clampedX = rawX;
            let clampedY = rawY;

            if (dist > maxDist) {
                clampedX = (rawX / dist) * maxDist;
                clampedY = (rawY / dist) * maxDist;
            }
            // Normalize based on max distance the *thumb* can travel
            const normX = maxDist > 0 ? clampedX / maxDist : 0;
            const normY = maxDist > 0 ? clampedY / maxDist : 0;


            if (thumbElement) {
                thumbElement.style.transform = `translate(${clampedX}px, ${clampedY}px)`;
            }

            if (type === 'move') {
                moveJoystickPosition.x = normX;
                moveJoystickPosition.y = normY; // Y is inverted in screen coords vs movement coords
                const deadzone = 0.2;
                // Use normalized Y for forward/backward (negative Y is up/forward)
                moveForward = moveJoystickPosition.y < -deadzone;
                moveBackward = moveJoystickPosition.y > deadzone;
                moveLeft = moveJoystickPosition.x < -deadzone;
                moveRight = moveJoystickPosition.x > deadzone;
            } else if (type === 'look') {
                lookJoystickPosition.x = normX;
                lookJoystickPosition.y = normY;
            }
        }

        // Simplified - just needs type and thumb
        function handleJoystickEnd(type, thumbElement) {
            if (type === 'move') {
                moveJoystickActive = false;
                moveJoystickPosition = { x: 0, y: 0 };
                moveForward = moveBackward = moveLeft = moveRight = false;
            } else if (type === 'look') {
                lookJoystickActive = false;
                lookJoystickPosition = { x: 0, y: 0 };
            }
            if (thumbElement) {
                thumbElement.style.transform = 'translate(0px, 0px)';
            }
        }


        function handlePointerLockChange() {
            const canvas = renderer.domElement;
            if (document.pointerLockElement === canvas || document.mozPointerLockElement === canvas) {
                console.log('Pointer Lock active');
                 // Show crosshair only in first person view
                 if (!thirdPersonView && document.getElementById('crosshair')) {
                     document.getElementById('crosshair').style.display = 'block';
                 }
            } else {
                console.log('Pointer Lock inactive');
                 // If game is running and not explicitly paused by user, trigger pause
                if (gameActive && !isPaused && document.getElementById('startScreen').style.display === 'none') {
                    togglePause(); // Auto-pause if lock is lost during gameplay
                }
                if (document.getElementById('crosshair')) {
                    document.getElementById('crosshair').style.display = 'none';
                }
                // Reset movement/shooting states when pointer lock is lost
                moveForward = moveBackward = moveLeft = moveRight = isShooting = false;
            }
        }


        function handlePointerLockError(e) {
             console.error('Pointer Lock Error:', e);
             // Optional: Display a message to the user
        }

        function shoot() {
            const now = Date.now();
            // Use the single fixed cooldown defined globally
            if (now - lastShootTime < shootCooldown) return;

            lastShootTime = now;

            addRecoil();
            createAndAddBullet(); // Simplified call, no spread args needed
            playSound('shoot');
            createMuzzleFlash();
        }

        function addRecoil() {
            const weaponHolder = camera.getObjectByName("weaponHolder");
            // No recoil effect in 3rd person or if weapon holder isn't found
            if (!weaponHolder || thirdPersonView) return;

            const recoilAmount = 0.04; // Pitch rotation amount
             const recoilPushBack = 0.05; // How far the gun model moves back
             const recoilDuration = 80; // How quickly it returns (ms)

             // Apply camera pitch kick (upwards)
            camera.rotation.x -= recoilAmount;
             // Clamp pitch to prevent excessive rotation
             camera.rotation.x = THREE.MathUtils.clamp(camera.rotation.x, minPitch, maxPitch);

            // Apply weapon model push back
            const initialZ = weaponHolder.userData.initialZ !== undefined ? weaponHolder.userData.initialZ : weaponHolder.position.z;
             if (weaponHolder.userData.initialZ === undefined) weaponHolder.userData.initialZ = initialZ; // Store initial pos first time

            weaponHolder.position.z = initialZ + recoilPushBack;

            // Simple timeout to return weapon model to original position
             // Clear any existing recoil timeout to prevent jitter if firing rapidly
             if (weaponHolder.userData.recoilTimeout) clearTimeout(weaponHolder.userData.recoilTimeout);

            weaponHolder.userData.recoilTimeout = setTimeout(() => {
                if (weaponHolder && !thirdPersonView) { // Check again in case view changed
                    weaponHolder.position.z = initialZ;
                }
                weaponHolder.userData.recoilTimeout = null; // Clear timeout reference
            }, recoilDuration);
        }


        function createMuzzleFlash() {
            const weaponHolder = camera.getObjectByName("weaponHolder");
            // No flash in 3rd person or if holder/weapon not visible/found
            if (!weaponHolder || weaponHolder.children.length === 0 || thirdPersonView || !weaponHolder.visible) return;

            const flashColor = 0xffaa33;
             const flashIntensity = 1.5; // Brighter flash
             const flashDistance = 5; // Slightly larger range
             const flashDuration = 60; // Shorter duration

            // Check if a flash already exists, remove it first if needed (prevents multiple flashes)
            const existingFlash = weaponHolder.getObjectByName("muzzleFlash");
            if (existingFlash) {
                 weaponHolder.remove(existingFlash);
            }

            // Create new flash light
            const flash = new THREE.PointLight(flashColor, flashIntensity, flashDistance);
            flash.name = "muzzleFlash"; // Name it for easy removal
            // Position roughly at the end of the default weapon visual's barrel
            flash.position.set(0, 0, -0.4); // Adjust based on weapon model visual
            weaponHolder.add(flash);

            // Remove the flash after a short duration
            setTimeout(() => {
                 const currentFlash = weaponHolder.getObjectByName("muzzleFlash");
                if (currentFlash) { // Check if it still exists before removing
                     weaponHolder.remove(currentFlash);
                 }
            }, flashDuration);
        }


        function createAndAddBullet() { // No spread args needed
            const bullet = createBullet(); // Gets the bullet mesh with userData

            // Calculate direction based on current camera orientation
            const direction = new THREE.Vector3(0, 0, -1);
             // Use world quaternion for accurate direction regardless of player/camera nesting
            camera.getWorldQuaternion(bullet.userData.worldQuaternion); // Store world rotation at spawn time
            direction.applyQuaternion(bullet.userData.worldQuaternion); // Apply rotation to get direction vector
            bullet.userData.direction = direction; // Store the direction vector

            // Calculate start position based on camera's world position
            const startPosition = new THREE.Vector3();
            camera.getWorldPosition(startPosition);
            // Offset slightly forward from camera to avoid hitting player model
            bullet.position.copy(startPosition).addScaledVector(direction, 0.8);

             // Align bullet mesh to face the direction of travel (optional, but can look better)
             bullet.quaternion.copy(bullet.userData.worldQuaternion);


            scene.add(bullet);
            bullets.push(bullet);
        }


        function createBullet() {
            // Fixed bullet properties (no longer depends on weapon type)
            const bulletColor = 0xffffaa; // Consistent bright yellow
            const bulletSize = 0.1; // Smaller, faster looking bullet
            const bulletSpeed = 1.5; // Faster speed
            const bulletPower = 45; // Fixed damage

            const bulletGeometry = new THREE.SphereGeometry(bulletSize, 6, 6); // Simpler geometry
            const bulletMaterial = new THREE.MeshBasicMaterial({ color: bulletColor });
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);

             // Add a subtle trail light attached to the bullet
            const trailLight = new THREE.PointLight(bulletColor, 0.5, 1.5); // Dimmer, shorter range light
             trailLight.position.set(0, 0, 0); // At bullet center
            bullet.add(trailLight);

            bullet.userData = {
                speed: bulletSpeed,
                created: Date.now(),
                power: bulletPower,
                direction: new THREE.Vector3(), // Will be set in createAndAddBullet
                 worldQuaternion: new THREE.Quaternion() // Will store world rotation at spawn
            };
            return bullet;
        }


        function updateBullets(delta) {
            const speedFactor = delta * 60; // Adjust speed based on frame time
            const groundSize = 100; // Map boundary

            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                const bulletData = bullet.userData;

                // Move bullet based on its stored direction and speed
                bullet.position.addScaledVector(bulletData.direction, bulletData.speed * speedFactor);

                let hit = false;

                // --- Check Enemy Collision ---
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    if (!enemy || !enemy.visible || !enemy.userData) continue; // Skip invalid or dying enemies

                    const enemySize = enemy.userData.size || 1.0;
                    // Use bounding sphere collision check (adjust radius as needed)
                    const collisionRadius = enemySize * 0.8; // Enemy's approximate radius
                    if (bullet.position.distanceTo(enemy.position.clone().add(new THREE.Vector3(0, 1.0, 0))) < collisionRadius) { // Check distance to enemy center (approx y=1)
                        hit = true;
                        enemy.userData.health -= bulletData.power;
                        playSound('hit');
                        // Create smaller, red impact spark effect
                        createExplosion(bullet.position.clone(), new THREE.Color(0xcc0000), 8, 0.05); // Smaller count/size

                        // --- Enemy Hit Visual Feedback ---
                        const originalMaterials = [];
                        enemy.traverseVisible(child => { // Only traverse visible parts
                            if (child.isMesh && child.material) {
                                // Handle both single and multi-materials
                                const materials = Array.isArray(child.material) ? child.material : [child.material];
                                materials.forEach(mat => {
                                     if (!mat.userData.originalColor) { // Store original only once
                                        mat.userData.originalColor = mat.color.clone();
                                        mat.userData.originalEmissive = mat.emissive ? mat.emissive.clone() : new THREE.Color(0x000000);
                                     }
                                     mat.color.set(0xffffff); // Flash white
                                     // mat.emissive.set(0xffffff); // Optional: make it glow white briefly
                                });

                                // Store reference to reset later
                                originalMaterials.push({ mesh: child });

                                 // Clear previous timeout if hit again quickly
                                 if (child.userData.hitTimeout) clearTimeout(child.userData.hitTimeout);

                                // Set timeout to revert color
                                child.userData.hitTimeout = setTimeout(() => {
                                    if (child && child.material) { // Check if mesh/material still exists
                                        const materialsToReset = Array.isArray(child.material) ? child.material : [child.material];
                                        materialsToReset.forEach(mat => {
                                             if (mat.userData.originalColor) {
                                                mat.color.copy(mat.userData.originalColor);
                                                // mat.emissive.copy(mat.userData.originalEmissive);
                                                 // delete mat.userData.originalColor; // Clean up
                                                 // delete mat.userData.originalEmissive;
                                             } else {
                                                 // Fallback if original wasn't stored somehow
                                                 mat.color.set(0x888888); // Default grey
                                                 // mat.emissive.set(0x000000);
                                             }
                                        });
                                    }
                                     child.userData.hitTimeout = null;
                                }, 100); // Duration of the flash
                            }
                        });

                        // --- Enemy Death Check ---
                        if (enemy.userData.health <= 0) {
                             // Ensure we don't process death multiple times if hit by multiple bullets quickly
                             if (!enemy.userData.isDying) {
                                 enemy.userData.isDying = true; // Mark as dying
                                 animateEnemyDeath(enemy); // Start death animation/effects

                                 // Schedule removal from array/scene *after* animation might finish
                                 setTimeout(() => {
                                     const index = enemies.indexOf(enemy);
                                     if (index > -1) {
                                         // Remove from scene first (important!)
                                         if (scene.getObjectById(enemy.id)) {
                                             scene.remove(enemy);
                                         }
                                         // Then remove from array
                                         enemies.splice(index, 1);

                                         // Update score, check level completion etc. only *after* confirming removal
                                         score += enemy.userData.type === 'fast' ? 20 : (enemy.userData.type === 'tank' ? 30 : 10);
                                         enemiesKilled++;
                                         updateUI(); // Update score/enemy count

                                         // Chance to spawn health power-up
                                         if (Math.random() < 0.15) {
                                             spawnPowerUp(enemy.position.clone()); // Spawn at enemy's last position
                                         }

                                         // Check if level is complete
                                         if (enemies.length === 0) {
                                             levelComplete();
                                         }
                                     }
                                 }, 1100); // Delay slightly longer than animation
                             }
                        }
                        break; // Bullet hits one enemy and is consumed
                    }
                }

                // --- Check Obstacle Collision ---
                if (!hit) {
                     for (const obstacle of obstacles) {
                          if (!obstacle || !obstacle.scale) continue; // Skip invalid obstacles

                         // Simple AABB collision check (Axis-Aligned Bounding Box)
                         const obsPos = obstacle.position;
                         const obsScale = obstacle.scale;
                         const halfScaleX = obsScale.x / 2;
                         const halfScaleY = obsScale.y / 2;
                         const halfScaleZ = obsScale.z / 2;
                         const bulletPos = bullet.position;

                         if ( bulletPos.x >= obsPos.x - halfScaleX && bulletPos.x <= obsPos.x + halfScaleX &&
                              bulletPos.y >= obsPos.y - halfScaleY && bulletPos.y <= obsPos.y + halfScaleY && // Check Y axis too
                              bulletPos.z >= obsPos.z - halfScaleZ && bulletPos.z <= obsPos.z + halfScaleZ )
                         {
                             hit = true;
                             // Create smaller, grey spark effect for hitting inanimate object
                             createExplosion(bullet.position.clone(), new THREE.Color(0xaaaaaa), 5, 0.04);
                             break; // Bullet hits one obstacle and is consumed
                         }
                     }
                }


                // --- Remove Bullet ---
                const age = Date.now() - bulletData.created;
                // Remove if hit, too old, or out of bounds
                 const outOfBounds = Math.abs(bullet.position.x) > groundSize / 2 + 5 ||
                                    Math.abs(bullet.position.z) > groundSize / 2 + 5 ||
                                    bullet.position.y < -1 || bullet.position.y > 50;

                if (hit || age > 3000 || outOfBounds) {
                    // Remove light first if it exists
                     if (bullet.children.length > 0 && bullet.children[0].isLight) {
                         bullet.remove(bullet.children[0]);
                     }
                    scene.remove(bullet);
                    bullets.splice(i, 1);
                }
            }
        }


        function animateEnemyDeath(enemy) {
            // No need for a clone if we just animate the original and mark it
            enemy.userData.isDying = true; // Mark it so other systems ignore it
            enemy.visible = true; // Ensure visible for animation start

             // Choose death effect color based on type
            const deathColor = enemy.userData.type === 'tank' ? new THREE.Color(0x4444ff) :
                               (enemy.userData.type === 'fast' ? new THREE.Color(0xff4444) : new THREE.Color(0x44ff44));
             // Create a larger explosion effect at the enemy's base
            createExplosion(enemy.position.clone(), deathColor, 30, 0.1); // Larger particles
            playSound('explode');

            const startTime = Date.now();
            const duration = 1000; // Animation duration in ms
             const originalScale = enemy.scale.clone(); // Store original scale
             const originalPosition = enemy.position.clone(); // Store original position

            function animateDeathFrame() {
                if (!enemy.userData.isDying) return; // Stop if somehow resurrected or already removed

                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1); // Normalized progress (0 to 1)

                // --- Animation Effects ---
                // 1. Sink into the ground
                enemy.position.y = originalPosition.y - progress * 1.0; // Sink down

                // 2. Scale down slightly
                enemy.scale.copy(originalScale).multiplyScalar(1 - progress * 0.5);

                // 3. Rotate randomly while sinking (optional)
                enemy.rotation.x += 0.1 * (1-progress);
                enemy.rotation.z += 0.08 * (1-progress);


                // 4. Fade out using material opacity
                enemy.traverseVisible(child => {
                    if (child.isMesh && child.material) {
                        const materials = Array.isArray(child.material) ? child.material : [child.material];
                        materials.forEach(mat => {
                            mat.transparent = true; // Ensure transparency is enabled
                            mat.opacity = 1.0 - progress; // Fade out
                        });
                    }
                });

                // Continue animation or finalize
                if (progress < 1) {
                    requestAnimationFrame(animateDeathFrame);
                } else {
                     // Animation finished - the removal is handled by the setTimeout in updateBullets
                     // We don't remove the mesh here anymore to avoid race conditions
                     enemy.visible = false; // Ensure it's hidden after animation
                }
            }
            animateDeathFrame(); // Start the animation loop
        }



        function updateEnemies(delta) {
            if (!player || !gameActive || isPaused) return; // Ensure player exists and game is active/unpaused
            const speedFactor = delta * 60; // Frame-rate independent speed adjustment
            const now = Date.now();

            for (let i = enemies.length - 1; i >= 0; i--) { // Iterate backwards for safe removal
                const enemy = enemies[i];

                 // Skip processing if enemy is invalid, already dead, or being animated for death
                 if (!enemy || !enemy.userData || enemy.userData.isDying || !enemy.visible) {
                    continue;
                 }


                animateEnemy(enemy, delta); // Handle walk/bob animation

                // --- Play Zombie Sound ---
                if (now - enemy.userData.lastSoundTime > enemy.userData.soundCooldown) {
                    enemy.userData.lastSoundTime = now;
                    // Recalculate next sound time randomly
                    enemy.userData.soundCooldown = (enemy.userData.type === 'fast' ? 4000 : (enemy.userData.type === 'tank' ? 6000 : 5000)) * (0.75 + Math.random() * 0.5);
                    // Play sound only if reasonably close to player
                    if (enemy.position.distanceTo(player.position) < 30) {
                        playSound('zombie');
                    }
                }

                // --- Movement and Targeting ---
                const distanceToPlayer = enemy.position.distanceTo(player.position);
                const attackRange = 1.5 * (enemy.userData.size || 1.0); // Range based on enemy size

                if (distanceToPlayer > attackRange) {
                    // Move towards player if outside attack range
                    const pathDirection = calculatePathToPlayer(enemy); // Get calculated direction (avoids obstacles/enemies)
                    pathDirection.normalize(); // Ensure it's a unit vector

                    const enemySpeed = enemy.userData.speed * speedFactor;

                    // Apply movement
                     const proposedMove = pathDirection.multiplyScalar(enemySpeed);
                     enemy.position.add(proposedMove);

                    // Make enemy look towards the player (only Y rotation)
                    enemy.lookAt(player.position.x, enemy.position.y, player.position.z); // Keep enemy upright

                } else {
                    // --- Attack Player ---
                    // Player is within range, check attack cooldown
                     if (now - enemy.userData.lastAttackTime > enemy.userData.attackCooldown) {
                        enemy.userData.lastAttackTime = now; // Reset attack timer

                         // Check if playerInvincible flag is set (though it's not used elsewhere yet)
                         if (!playerInvincible) {
                             health -= enemy.userData.damage;
                             showDamageEffect(); // Visual feedback for player getting hit
                             if (Math.random() < 0.7) playSound('pain'); // Play pain sound sometimes
                             updateUI(); // Update health display

                             // Check for game over
                             if (health <= 0) {
                                 gameOver();
                                 break; // Exit enemy loop immediately if game over
                             }
                         }
                    }
                     // Optional: Make the enemy stop moving or just jitter slightly when attacking
                     // enemy.position remains the same or add very small random movement
                }

                 // --- Ground Clamp ---
                 // Ensure enemy stays on the ground plane (y=0)
                 enemy.position.y = 0;
            }
        }


        function showDamageEffect() {
            const overlay = document.getElementById('damageOverlay');
            if (!overlay) return;

             // Make overlay visible briefly
            overlay.style.backgroundColor = 'rgba(255, 0, 0, 0.4)'; // More visible red flash
             overlay.style.transition = 'background-color 0.1s'; // Faster flash transition

            // Use a timeout to fade it back to transparent
            setTimeout(() => {
                overlay.style.backgroundColor = 'rgba(255, 0, 0, 0)';
                 overlay.style.transition = 'background-color 0.5s'; // Slower fade out
            }, 150); // Duration of the flash effect
        }


        function animateEnemy(enemy, delta) {
            if (!enemy || !enemy.userData || enemy.userData.isDying) return; // Skip if invalid or dying

             // Use stored walkTime and walkSpeed from userData
             enemy.userData.walkTime += delta * enemy.userData.walkSpeed;
             const walkCycle = enemy.userData.walkTime;

            // Basic arm swing animation
            const leftArm = enemy.getObjectByName('leftArm');
            const rightArm = enemy.getObjectByName('rightArm');
            const armSwingAmount = 0.6; // Radians

            if (leftArm) {
                leftArm.rotation.x = Math.sin(walkCycle) * armSwingAmount;
            }
            if (rightArm) {
                rightArm.rotation.x = -Math.sin(walkCycle) * armSwingAmount; // Opposite swing
            }

             // Gentle body bobbing - ensure this doesn't conflict with ground clamping in updateEnemies
             // Maybe skip this if ground clamp is strict? Or apply bobbing *before* clamping.
             // Let's disable this for now to ensure y=0 is maintained by updateEnemies.
            // enemy.position.y = Math.abs(Math.sin(walkCycle * 0.5)) * 0.05;
        }


        function calculatePathToPlayer(enemy) {
             if (!player || !enemy || !enemy.userData) return new THREE.Vector3(0, 0, 0); // Safety check

            // 1. Direct vector towards player
            const directPath = new THREE.Vector3().subVectors(player.position, enemy.position);
            directPath.y = 0; // Ignore vertical difference for pathfinding
             if (directPath.lengthSq() < 0.01) return directPath; // Already at player, no need to move/avoid

             directPath.normalize(); // Start with the ideal direction

             // 2. Avoidance Vector Calculation
            let avoidVector = new THREE.Vector3();
             const enemySize = (enemy.userData.size || 1.0) * 0.5; // Enemy radius
             const avoidanceStrength = 1.5; // How strongly to push away
             const lookAheadDistance = enemy.userData.speed * 60 * 0.2; // How far ahead to check for collisions (e.g., 0.2 seconds)

             // --- Avoid other enemies ---
             enemies.forEach(other => {
                 if (enemy === other || !other.userData || other.userData.isDying || !other.visible) return; // Skip self, invalid, or dying

                 const otherSize = (other.userData.size || 1.0) * 0.5;
                 const vecToOther = new THREE.Vector3().subVectors(other.position, enemy.position);
                 vecToOther.y = 0;
                 const distToOther = vecToOther.length();
                 const minSeparation = enemySize + otherSize + 0.2; // Desired minimum separation buffer

                 if (distToOther < minSeparation) {
                      // Calculate how much to push away, stronger when closer
                     const avoidanceScale = (1.0 - distToOther / minSeparation) * avoidanceStrength;
                     vecToOther.normalize().multiplyScalar(-avoidanceScale); // Push directly away
                     avoidVector.add(vecToOther);
                 }
             });

             // --- Avoid obstacles ---
             obstacles.forEach(obstacle => {
                 if (!obstacle.scale) return; // Skip if scale isn't defined

                 const obsPos = obstacle.position;
                 const obsScale = obstacle.scale;
                 const obsRadius = Math.max(obsScale.x, obsScale.z) / 2; // Approximate radius

                 const vecToObstacle = new THREE.Vector3().subVectors(obsPos, enemy.position);
                 vecToObstacle.y = 0;
                 const distToObstacle = vecToObstacle.length();
                 const minSeparation = enemySize + obsRadius + 0.5; // Larger buffer for obstacles

                  if (distToObstacle < minSeparation) {
                      // Calculate avoidance based on distance
                      const avoidanceScale = (1.0 - distToObstacle / minSeparation) * avoidanceStrength * 1.5; // Obstacles are more important to avoid
                      vecToObstacle.normalize().multiplyScalar(-avoidanceScale); // Push away
                      avoidVector.add(vecToObstacle);
                  }
             });


            // 3. Combine Direct Path and Avoidance
             const combinedPath = directPath.clone();
             combinedPath.add(avoidVector); // Add the avoidance influence
             combinedPath.normalize(); // Final direction is normalized

            return combinedPath;
        }



        function updateParticles(delta) {
            const now = Date.now();
             const speedFactor = delta * 60; // Frame-rate independent factor

            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                const data = p.userData;

                if (!data) { // Safety check
                     scene.remove(p);
                     particles.splice(i, 1);
                     continue;
                 }

                // Apply velocity and gravity
                p.position.addScaledVector(data.direction, data.speed * speedFactor);
                data.direction.y -= data.gravity * delta; // Gravity adjusted by delta directly

                // Update lifetime and calculate life ratio
                const age = now - data.created;
                const lifeRatio = Math.max(0, 1 - (age / data.lifetime));

                // Update scale based on life ratio (shrink over time)
                 p.scale.setScalar(Math.max(0.01, lifeRatio * data.initialScale)); // Use stored initial scale

                // Update material opacity for fade out
                 if (p.material && p.material.transparent) {
                     p.material.opacity = lifeRatio * data.initialOpacity;
                 }

                 // Update attached light intensity
                 if (data.light) {
                     data.light.intensity = lifeRatio * data.initialLightIntensity;
                 }

                // Remove particle if lifetime exceeded or too small/faded
                if (lifeRatio <= 0) {
                     if (data.light) p.remove(data.light); // Remove light first
                     scene.remove(p);
                     particles.splice(i, 1);
                }
            }
        }


        function updatePowerUps(delta) {
            const now = Date.now();
            const pickupRadius = 1.5; // How close player needs to be
            const lifetime = 20000; // 20 seconds in ms

            for (let i = powerUps.length - 1; i >= 0; i--) {
                const powerUp = powerUps[i];
                const data = powerUp.userData;

                if (!data) { // Safety check
                    scene.remove(powerUp);
                    powerUps.splice(i, 1);
                    continue;
                }

                // --- Animation ---
                // Rotation
                powerUp.rotation.y += data.rotationSpeed;
                // Bobbing
                 const hoverOffset = Math.sin(now * data.hoverFrequency) * data.hoverAmplitude;
                powerUp.position.y = data.hoverBaseHeight + hoverOffset;

                // Optional: Light pulsing effect
                 const light = powerUp.getObjectByProperty('isLight', true);
                 if (light) {
                     light.intensity = 0.6 + Math.sin(now * 0.005) * 0.2; // Pulse intensity
                 }

                // --- Check Player Collision ---
                 if (player && player.position.distanceTo(powerUp.position) < pickupRadius) {
                    collectPowerUp(powerUp);
                     // Remove immediately on collection
                     if (light) powerUp.remove(light); // Clean up light
                    scene.remove(powerUp);
                    powerUps.splice(i, 1);
                    continue; // Move to next powerup
                }

                // --- Check Lifetime ---
                const age = now - data.created;
                if (age > lifetime) {
                     // Start fade out animation instead of immediate removal
                     if (!data.isFading) { // Check if already fading
                         fadeOutAndRemove(powerUp, 500); // Start 500ms fade
                         data.isFading = true; // Mark as fading
                     }
                     // Actual removal will be handled by fadeOutAndRemove completion or a later check
                }

                 // Optional: Cleanup faded objects that might have been missed
                 if (data.isFading && age > lifetime + 1000) { // If still here 1s after fade should have ended
                    if (light) powerUp.remove(light);
                    scene.remove(powerUp);
                    powerUps.splice(i, 1);
                 }
            }
        }


        function fadeOutAndRemove(object, duration = 500) { // Added duration parameter
            if (!object || !object.userData) return; // Safety check

             object.userData.isFading = true; // Mark it
            const startTime = Date.now();
             const startScale = object.scale.clone(); // Store initial scale for smooth scaling

            function fadeOutFrame() {
                 if (!object.userData.isFading || !object.parent) { // Stop if removed elsewhere or flag cleared
                      // Ensure cleanup if stopped prematurely
                      if (object.parent) scene.remove(object);
                      const index = powerUps.indexOf(object); // Also remove from powerup array if it's one
                      if (index > -1) powerUps.splice(index,1);
                      return;
                  }

                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const remaining = 1.0 - progress;

                // Scale down
                 object.scale.copy(startScale).multiplyScalar(remaining);

                // Fade opacity
                object.traverse(child => {
                    if (child.isMesh && child.material) {
                        const materials = Array.isArray(child.material) ? child.material : [child.material];
                        materials.forEach(mat => {
                            mat.transparent = true; // Ensure transparency
                            mat.opacity = remaining;
                        });
                    }
                    // Fade light
                     if (child.isLight) {
                         // Assuming initial intensity was stored or is known (e.g., 1.0)
                         child.intensity = (child.userData.initialIntensity || 0.7) * remaining;
                     }
                });

                if (progress < 1) {
                    requestAnimationFrame(fadeOutFrame);
                } else {
                    // Animation complete, remove from scene and arrays
                     const light = object.getObjectByProperty('isLight', true);
                     if (light) object.remove(light);
                     if (object.parent) scene.remove(object); // Final removal from scene

                     // Remove from powerUps array if it's a power-up
                     const index = powerUps.indexOf(object);
                     if (index > -1) powerUps.splice(index, 1);

                     // Note: Also needs removal from 'particles' array if it's a particle being faded.
                     // This function is generic, so the caller might need array cleanup.
                }
            }
            fadeOutFrame(); // Start the animation
        }



        function createExplosion(position, color, count = 20, particleBaseScale = 0.1, particleSpeedMult = 1.0) {
            const baseLifetime = 400 + Math.random() * 400; // Base duration for particles

            for (let i = 0; i < count; i++) {
                 // Use a very simple geometry (plane or small sphere)
                const particleGeometry = new THREE.SphereGeometry(0.5, 4, 2); // Start with unit size, scale later
                const particleMaterial = new THREE.MeshBasicMaterial({
                     color: color,
                     transparent: true,
                     opacity: 0.9, // Start slightly transparent
                     // Optional: Blending for additive effect
                     // blending: THREE.AdditiveBlending,
                     // depthWrite: false // Disable depth write for additive blending
                 });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.copy(position);

                // Random direction (more outward than upward bias)
                const direction = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 1.5, // Less vertical spread
                    (Math.random() - 0.5) * 2
                ).normalize(); // Normalize for consistent speed base

                // User data for particle simulation
                particle.userData = {
                    direction: direction,
                    speed: (0.05 + Math.random() * 0.15) * particleSpeedMult, // Base speed + randomness * multiplier
                    gravity: 0.005, // Lower gravity effect
                    created: Date.now(),
                    lifetime: baseLifetime * (0.8 + Math.random() * 0.4), // Vary lifetime slightly
                    initialScale: particleBaseScale * (0.7 + Math.random() * 0.6), // Vary initial scale
                    initialOpacity: particleMaterial.opacity, // Store initial opacity
                    light: null, // Placeholder for optional light
                    initialLightIntensity: 0 // Placeholder
                };

                 // Initial scale set here
                 particle.scale.setScalar(particle.userData.initialScale);

                 // Less frequent, dimmer lights
                 if (Math.random() < 0.15 && count > 10) { // Add light only for larger explosions, less often
                     const light = new THREE.PointLight(color, 0.4, 1.5); // Dimmer, shorter range
                     particle.userData.light = light;
                     particle.userData.initialLightIntensity = light.intensity;
                     particle.add(light); // Attach light to particle
                 }

                scene.add(particle);
                particles.push(particle);
            }
        }



        function playSound(type) {
            // Check if audio context exists and is running
            if (!audioContext || audioContext.state !== 'running' || !soundEffects[type]) {
                // console.warn(`Audio not ready or sound type "${type}" unknown.`);
                return;
            }

            // Determine volume based on type
            let volume = 0.7; // Default volume
            switch(type) {
                case 'shoot':   volume = 0.5; break; // Quieter shoot
                case 'zombie':  volume = 0.35; break;// Quieter ambient zombie
                case 'hit':     volume = 0.4; break;
                case 'explode': volume = 0.8; break; // Louder explosion
                case 'powerUp': volume = 0.6; break;
                case 'pain':    volume = 0.5; break; // Player pain sound
            }

            // Play the sound
            soundEffects[type].play(volume);
        }


        function updatePlayer(delta) {
            const moveSpeed = playerSpeed * delta;
            const touchLookSpeed = touchSensitivity * delta * 60; // Frame-rate adjust look speed

            // --- Touch Look ---
            if (lookJoystickActive && !thirdPersonView) { // Only apply touch look in 1st person
                // Horizontal rotation (around Y axis) - affects player group
                player.rotation.y -= lookJoystickPosition.x * touchLookSpeed * 1.5; // Increase sensitivity slightly

                // Vertical rotation (around X axis) - affects camera directly
                camera.rotation.x -= lookJoystickPosition.y * touchLookSpeed;
                camera.rotation.x = THREE.MathUtils.clamp(camera.rotation.x, minPitch, maxPitch);
            }

            // --- Movement Calculation ---
            const forwardVector = new THREE.Vector3();
            const rightVector = new THREE.Vector3();
            // Get player's forward direction (ignoring pitch)
            player.getWorldDirection(forwardVector);
            forwardVector.y = 0; // Project onto XZ plane
            forwardVector.normalize();
            // Calculate right vector based on forward vector
            rightVector.crossVectors(new THREE.Vector3(0, 1, 0), forwardVector).normalize();

            // Determine movement based on input flags
            let moveZ = 0;
            let moveX = 0;
            if (moveForward) moveZ -= 1;
            if (moveBackward) moveZ += 1;
            if (moveLeft) moveX -= 1;
            if (moveRight) moveX += 1;

            const moveDirection = new THREE.Vector3();
            moveDirection.addScaledVector(forwardVector, moveZ);
            moveDirection.addScaledVector(rightVector, moveX);

            // Normalize diagonal movement to prevent faster speed
            if (moveDirection.lengthSq() > 0) {
                moveDirection.normalize();
            }

            // --- Collision Detection and Application ---
            const proposedMovement = moveDirection.clone().multiplyScalar(moveSpeed);
            const proposedPosition = player.position.clone().add(proposedMovement);

             // Perform collision check with the proposed final position
             if (handleCollisions(proposedPosition)) {
                 // No collision detected, move the player
                 player.position.copy(proposedPosition);
             } else {
                 // Collision detected! Try sliding along the collision normal.
                 // This is a simplified slide: try moving only on X, then only on Z.
                 // A more robust solution involves projecting movement onto the collision plane.

                 // Try X-only movement
                 const proposedX = player.position.clone().add(new THREE.Vector3(proposedMovement.x, 0, 0));
                 if (handleCollisions(proposedX)) {
                     player.position.copy(proposedX);
                 } else {
                     // Try Z-only movement
                     const proposedZ = player.position.clone().add(new THREE.Vector3(0, 0, proposedMovement.z));
                     if (handleCollisions(proposedZ)) {
                         player.position.copy(proposedZ);
                     }
                     // If both fail, player stops against the obstacle/wall
                 }
             }


            // --- Boundary Clamp (Final safety net) ---
            const mapBoundary = 100 / 2 - 0.5; // Half map size minus player radius
            player.position.x = Math.max(-mapBoundary, Math.min(mapBoundary, player.position.x));
            player.position.z = Math.max(-mapBoundary, Math.min(mapBoundary, player.position.z));
            player.position.y = 0.5; // Ensure player stays at correct height


            // --- Continuous Shooting ---
            // Call shoot repeatedly if the flag is set (by mouse down or touch start)
            if (isShooting) {
                shoot(); // shoot() handles its own cooldown
            }

            // --- Weapon Bobbing (1st person only) ---
            const isMoving = moveForward || moveBackward || moveLeft || moveRight;
            if (isMoving && !thirdPersonView) {
                animateWeaponBob(delta);
            } else if (!thirdPersonView) {
                 resetWeaponBob(); // Smoothly return weapon to default position if stopped
            }
        }


        function handleCollisions(proposedPosition) {
            const playerRadius = 0.4; // Player collision cylinder radius
            const playerHeight = 1.8; // Player collision cylinder height (for potential future use)

             // Iterate through all obstacles (including walls added earlier)
            for (const obstacle of obstacles) {
                 if (!obstacle || !obstacle.scale || !obstacle.position) continue; // Skip invalid

                const obsPos = obstacle.position;
                const obsScale = obstacle.scale;

                // --- Simplified Cylinder vs AABB Collision ---
                // We treat the player as a cylinder and obstacles as Axis-Aligned Bounding Boxes (AABB)
                // This is an approximation, especially for non-box obstacles.

                // Find the closest point on the AABB to the center of the player cylinder's base
                const closestX = Math.max(obsPos.x - obsScale.x / 2, Math.min(proposedPosition.x, obsPos.x + obsScale.x / 2));
                const closestZ = Math.max(obsPos.z - obsScale.z / 2, Math.min(proposedPosition.z, obsPos.z + obsScale.z / 2));

                // Calculate the squared distance between the cylinder's center (on the XZ plane) and this closest point
                const dx = proposedPosition.x - closestX;
                const dz = proposedPosition.z - closestZ;
                const distanceSq = (dx * dx) + (dz * dz);

                // Check if the distance is less than the player's radius squared (collision on XZ plane)
                if (distanceSq < (playerRadius * playerRadius)) {
                    // Optional: Check Y-axis collision if obstacles have height variance
                     // const bottomOverlap = proposedPosition.y - playerHeight/2 < obsPos.y + obsScale.y/2;
                     // const topOverlap = proposedPosition.y + playerHeight/2 > obsPos.y - obsScale.y/2;
                     // For this game, assuming flat ground and obstacles start at y=-0.5, we mostly care about XZ.
                     // Let's assume Y collision if XZ collides for simplicity here.
                    // console.log("Collision with obstacle:", obstacle);
                    return false; // Collision detected
                }
            }

            // --- Boundary Check (redundant if walls are in obstacles, but safe) ---
            // const mapBoundary = 100 / 2; // World size
            // if (proposedPosition.x < -mapBoundary + playerRadius || proposedPosition.x > mapBoundary - playerRadius ||
            //     proposedPosition.z < -mapBoundary + playerRadius || proposedPosition.z > mapBoundary - playerRadius) {
            //      console.log("Collision with boundary");
            //     return false; // Hit boundary
            // }


            return true; // No collision detected
        }



        function animateWeaponBob(delta) {
            const weaponHolder = camera.getObjectByName("weaponHolder");
            if (!weaponHolder || thirdPersonView) return;

            const time = clock.getElapsedTime(); // Use total elapsed time for consistent cycle
            const bobFrequency = 10; // Slightly faster bob frequency
            const bobAmountX = 0.015; // Horizontal bob amount
            const bobAmountY = 0.018; // Vertical bob amount

            // Calculate bob offsets using sine/cosine waves
            const bobX = Math.sin(time * bobFrequency) * bobAmountX;
            const bobY = Math.abs(Math.cos(time * bobFrequency)) * bobAmountY; // Use abs(cos) for up/down motion

            // Apply bob relative to the weapon holder's base position (stored in userData)
            if (weaponHolder.userData.basePosition === undefined) {
                 weaponHolder.userData.basePosition = weaponHolder.position.clone();
            }
             const basePos = weaponHolder.userData.basePosition;
             weaponHolder.position.x = basePos.x + bobX;
             weaponHolder.position.y = basePos.y - bobY; // Subtract for downward bob
        }

        function resetWeaponBob() {
            const weaponHolder = camera.getObjectByName("weaponHolder");
            if (!weaponHolder || thirdPersonView || !weaponHolder.userData.basePosition) return;

            // Smoothly interpolate back to base position using LERP
             const lerpFactor = 0.1; // How quickly to return to base position
             weaponHolder.position.lerp(weaponHolder.userData.basePosition, lerpFactor);

             // Optional: Snap back if very close to avoid tiny movements
             if (weaponHolder.position.distanceToSquared(weaponHolder.userData.basePosition) < 0.0001) {
                 weaponHolder.position.copy(weaponHolder.userData.basePosition);
             }
        }



        function onWindowResize() {
            // Update camera aspect ratio
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            // Update renderer size and pixel ratio
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio); // Adjust for high DPI displays

            // Re-initialize minimap for new size/aspect ratio
            initMinimap();
        }

        function onKeyDown(event) {
            // Ignore input if game isn't active or is paused
            if (!gameActive || isPaused) return;

            switch (event.code) {
                case 'KeyW': case 'ArrowUp':    moveForward = true; break;
                case 'KeyA': case 'ArrowLeft':  moveLeft = true; break;
                case 'KeyS': case 'ArrowDown':  moveBackward = true; break;
                case 'KeyD': case 'ArrowRight': moveRight = true; break;
                 // Note: Space/Shoot is handled in a separate listener for initial press vs hold
                 // Note: V and Escape are handled in a separate listener
            }
        }

        function onKeyUp(event) {
            // No need to check gameActive/isPaused here, just reset flags
            switch (event.code) {
                case 'KeyW': case 'ArrowUp':    moveForward = false; break;
                case 'KeyA': case 'ArrowLeft':  moveLeft = false; break;
                case 'KeyS': case 'ArrowDown':  moveBackward = false; break;
                case 'KeyD': case 'ArrowRight': moveRight = false; break;
                 // Note: Space/Shoot release is handled in a separate listener
            }
        }

        function onMouseDown(event) {
            // Check if pointer is locked, game is active, not paused, and it's the left mouse button (button 0)
            if (document.pointerLockElement === renderer.domElement && gameActive && !isPaused && event.button === 0) {
                isShooting = true; // Set flag for continuous shooting in updatePlayer
            }
        }

        function onMouseUp(event) {
            // If left mouse button is released (button 0)
            if (event.button === 0) {
                isShooting = false; // Clear flag to stop continuous shooting
            }
        }

        function onMouseMove(event) {
            // Only rotate view if pointer is locked, game active, not paused, and not in 3rd person view
            if (document.pointerLockElement === renderer.domElement && gameActive && !isPaused && !thirdPersonView) {
                const movementX = event.movementX || event.mozMovementX || 0;
                const movementY = event.movementY || event.mozMovementY || 0;

                // Horizontal rotation (around Y axis) - apply to player group
                player.rotation.y -= movementX * mouseSensitivity;

                // Vertical rotation (around X axis) - apply to camera directly
                camera.rotation.x -= movementY * mouseSensitivity;
                // Clamp vertical rotation (pitch)
                camera.rotation.x = THREE.MathUtils.clamp(camera.rotation.x, minPitch, maxPitch);
            }
        }

        function updateUI() {
            if (!document.getElementById('score')) return; // Check if UI exists

            document.getElementById('score').textContent = score;
            document.getElementById('level').textContent = level;
            document.getElementById('health').textContent = Math.max(0, Math.round(health)); // Ensure health doesn't show negative
            document.getElementById('enemies').textContent = enemies.length;

            // --- Health Color Indicator ---
            const healthUI = document.getElementById('health');
            const overlay = document.getElementById('damageOverlay'); // Use existing overlay ref
            if (health < 30) {
                healthUI.style.color = 'red';
                // Apply a subtle, persistent red overlay tint when health is critical
                 if (overlay) overlay.style.backgroundColor = 'rgba(255, 0, 0, 0.1)';
            } else if (health < 60) {
                healthUI.style.color = 'orange';
                 // Clear overlay tint if not critical
                 if (overlay) overlay.style.backgroundColor = 'rgba(255, 0, 0, 0)';
            } else {
                healthUI.style.color = 'white';
                 // Clear overlay tint
                 if (overlay) overlay.style.backgroundColor = 'rgba(255, 0, 0, 0)';
            }
        }


        function levelComplete() {
             console.log(`Level ${level} Complete!`);
            level++;
            difficultyMultiplier += 0.1; // Increase difficulty slightly more

            // --- Display Level Info ---
            const levelInfo = document.getElementById('levelInfo');
            levelInfo.innerHTML = `LEVEL ${level}<br>Starting...`; // Use innerHTML for line break
            levelInfo.style.display = 'block';

            // --- Clean Up ---
             // Remove remaining bullets (if any)
             bullets.forEach(b => { if (b.parent) scene.remove(b); });
             bullets = [];
             // Remove remaining powerups
             powerUps.forEach(p => { if (p.parent) fadeOutAndRemove(p, 200); }); // Quick fade out
             powerUps = [];
             // Let existing particles fade naturally

            // --- Heal Player ---
            health = Math.min(health + 40, 100); // Heal a good amount, up to 100

            // --- Level Transition Effect ---
             const playerPos = player.position.clone();
             const effectColor = new THREE.Color(0.3, 0.7, 1.0); // Blueish color
             const numExplosions = 25;
             const effectDuration = 1500; // Total duration of the effect
             for (let i = 0; i < numExplosions; i++) {
                 setTimeout(() => {
                     // Spawn small explosions randomly around player
                     const offset = new THREE.Vector3(
                         (Math.random() - 0.5) * 10,
                         Math.random() * 3, // Vary height
                         (Math.random() - 0.5) * 10
                     );
                     const explosionPos = playerPos.clone().add(offset);
                     createExplosion(explosionPos, effectColor, 5, 0.05); // Small, few particles
                 }, (i / numExplosions) * effectDuration); // Spread explosions over duration
             }

             // Play a level-up sound (if available)
             // playSound('levelUp'); // Assuming you create such a sound

            // --- Start Next Level ---
            setTimeout(() => {
                levelInfo.style.display = 'none'; // Hide level indicator
                totalEnemies = Math.min(5 + level * 2, 30); // Increase enemies, cap at 30
                enemiesKilled = 0;
                 // Reset player position slightly (optional, prevents getting stuck)
                 // player.position.set(0, 0.5, 0);
                 // player.rotation.y = 0; camera.rotation.x = 0;

                spawnEnemies(totalEnemies); // Spawn new wave
                updateUI(); // Update UI for new level/health/enemy count
            }, effectDuration + 500); // Wait for effect to mostly finish + buffer
        }


        function startGame() {
            // Hide start screen, show game UI
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('ui').style.display = 'block';
            document.getElementById('minimap').style.display = 'block';

            // Reset game state variables
            score = 0;
            level = 1;
            health = 100;
            enemiesKilled = 0;
            totalEnemies = 5; // Initial enemy count for level 1
            difficultyMultiplier = 1.0;
            gameActive = true;
            isPaused = false;
            thirdPersonView = false; // Start in first person
            toggleView(); // Call once to ensure correct initial view setup (hides player body etc.)
            toggleView(); // Call again to return to desired starting view (1st person)

             // Clear existing game objects from previous sessions (if any)
             bullets.forEach(b => { if (b.parent) scene.remove(b); }); bullets = [];
             enemies.forEach(e => { if (e.parent) scene.remove(e); }); enemies = [];
             particles.forEach(p => { if (p.parent) scene.remove(p); }); particles = [];
             powerUps.forEach(pu => { if (pu.parent) scene.remove(pu); }); powerUps = [];


             // Reset player position and rotation
             if(player) {
                player.position.set(0, 0.5, 0);
                player.rotation.set(0, 0, 0);
                camera.rotation.set(0, 0, 0); // Reset camera pitch too
             } else {
                 createPlayer(); // Create player if it doesn't exist (shouldn't happen with reload restart)
             }


            // Spawn initial enemies for level 1
            spawnEnemies(totalEnemies);
            updateUI(); // Update UI with initial values

            // Start game clock and animation loop
            clock.start();

             // Request pointer lock for desktop
            if (!isMobile) {
                 renderer.domElement.requestPointerLock = renderer.domElement.requestPointerLock || renderer.domElement.mozRequestPointerLock;
                 renderer.domElement.requestPointerLock();
             } else {
                // Ensure touch controls are visible for mobile
                document.getElementById('touchControls').style.display = 'flex';
             }
             // Crosshair display is handled by pointer lock change event

            animate(); // Start the main game loop
        }


        function togglePause() {
            if (!gameActive) return; // Don't allow pausing if game isn't active (e.g., on game over screen)

            isPaused = !isPaused;
            const pauseScreen = document.getElementById('pauseScreen');

            if (isPaused) {
                clock.stop(); // Stop game time
                cancelAnimationFrame(gameLoop); // Stop rendering loop
                pauseScreen.style.display = 'flex'; // Show pause menu

                // Release pointer lock if it's held
                if (document.pointerLockElement === renderer.domElement || document.mozPointerLockElement === renderer.domElement) {
                    document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock;
                    document.exitPointerLock();
                }
                // Crosshair is hidden automatically by pointerlockchange handler
                document.getElementById('crosshair').style.display = 'none'; // Explicitly hide just in case

                // Reset movement/action flags to prevent unintended actions on resume
                moveForward = moveBackward = moveLeft = moveRight = isShooting = false;
                moveJoystickActive = lookJoystickActive = false;
                moveJoystickPosition = {x:0, y:0};
                lookJoystickPosition = {x:0, y:0};
                // Reset joystick thumb positions visually
                document.querySelectorAll('.joystick-thumb').forEach(thumb => {
                    thumb.style.transform = 'translate(0px, 0px)';
                });
                 // Hide touch controls while paused
                 if (isMobile) document.getElementById('touchControls').style.display = 'none';

            } else {
                clock.start(); // Resume game time
                pauseScreen.style.display = 'none'; // Hide pause menu

                // Re-request pointer lock for desktop
                if (!isMobile) {
                     renderer.domElement.requestPointerLock = renderer.domElement.requestPointerLock || renderer.domElement.mozRequestPointerLock;
                     renderer.domElement.requestPointerLock();
                }
                 // Crosshair display is handled by pointerlockchange handler
                 // Show touch controls again on resume
                 if (isMobile) document.getElementById('touchControls').style.display = 'flex';

                 // Resume Audio Context if it was suspended
                 if (audioContext && audioContext.state === 'suspended') {
                     audioContext.resume();
                 }

                animate(); // Restart rendering loop
            }
        }


        function gameOver() {
            if (!gameActive) return; // Prevent multiple calls

            console.log("GAME OVER");
            gameActive = false;
            isPaused = true; // Treat game over state similar to paused regarding input/updates

            cancelAnimationFrame(gameLoop); // Stop the animation loop
            clock.stop(); // Stop the game clock

            // Release pointer lock if held
            if (document.pointerLockElement === renderer.domElement || document.mozPointerLockElement === renderer.domElement) {
                 document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock;
                 document.exitPointerLock();
            }

            // Hide game elements
            document.getElementById('ui').style.display = 'none';
            document.getElementById('crosshair').style.display = 'none';
            document.getElementById('touchControls').style.display = 'none';
            document.getElementById('minimap').style.display = 'none';
            document.getElementById('levelInfo').style.display = 'none'; // Hide level info if it was showing
             if (document.getElementById('pauseScreen')) document.getElementById('pauseScreen').style.display = 'none'; // Hide pause if it was showing

            // Show game over screen
            document.getElementById('gameOver').style.display = 'flex';
            document.getElementById('finalScore').textContent = `Final Score: ${score} | Level Reached: ${level}`;

            // Reset input flags
            moveForward = moveBackward = moveLeft = moveRight = isShooting = false;
             moveJoystickActive = lookJoystickActive = false;
             moveJoystickPosition = {x:0, y:0};
             lookJoystickPosition = {x:0, y:0};
        }


        function restartGame() {
            console.log("Restarting game...");
            // Easiest and cleanest way to ensure a full reset
            location.reload();

            // --- Alternative (Manual Reset - More Complex, Avoids Reload) ---
            // // Hide Game Over / Pause Screen
            // document.getElementById('gameOver').style.display = 'none';
            // document.getElementById('pauseScreen').style.display = 'none';

            // // Call startGame to reset state and relaunch
            // startGame();
        }


        function animate() {
            // Request the next frame immediately
            gameLoop = requestAnimationFrame(animate);

            // Check game state *after* requesting next frame
            if (!gameActive || isPaused) {
                return; // Exit if game is over or paused
            }

            // Calculate delta time for frame-rate independence
            const delta = clock.getDelta();

            // --- Update Game Logic ---
            updatePlayer(delta);    // Player movement, input, weapon bob
            updateBullets(delta);   // Bullet movement, collision detection
            updateEnemies(delta);   // Enemy movement, AI, attacks
            updateParticles(delta); // Particle simulation (explosions, etc.)
            updatePowerUps(delta);  // Power-up animation, collision, lifetime
            drawMinimap();          // Redraw minimap contents

            // Render the scene
            renderer.render(scene, camera);
        }


        // --- Start Initialization ---
        window.onload = init; // Initialize the game when the window loads

    </script>
</body>
</html> 