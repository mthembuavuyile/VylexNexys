<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Avuyile's Bitcoin Adventure</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r132/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: manipulation;
        }
        
        body {
            overflow: hidden;
            font-family: 'Courier New', monospace;
            background-color: #000;
            color: #fff;
            height: 100vh;
            width: 100vw;
        }
        
        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        #ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            pointer-events: none;
        }
        
        #stats {
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            padding: 8px;
            margin-bottom: 10px;
            pointer-events: none;
        }
        
        #btc-count {
            color: #f7931a;
            font-weight: bold;
        }
        
        #level-indicator {
            color: #00ff00;
        }
        
        #message {
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            padding: 8px;
            margin-top: 10px;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
            max-width: 80vw;
        }
        
        .controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            pointer-events: none;
        }
        
        .joystick-area {
            width: 120px;
            height: 120px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            position: relative;
            pointer-events: auto;
        }
        
        .joystick-knob {
            width: 50px;
            height: 50px;
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .action-buttons {
            display: flex;
            gap: 15px;
            pointer-events: auto;
        }
        
        .action-button {
            width: 60px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 16px;
        }
        
        #jump-button {
            background-color: rgba(0, 255, 0, 0.3);
        }
        
        #action-button {
            background-color: rgba(255, 165, 0, 0.3);
        }
        
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        #start-screen h1 {
            font-size: 24px;
            margin-bottom: 20px;
            color: #f7931a;
            text-align: center;
            padding: 0 20px;
        }
        
        #start-button {
            background-color: #f7931a;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
        }
        
        #level-complete {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        #level-complete h1 {
            font-size: 24px;
            margin-bottom: 20px;
            color: #f7931a;
            text-align: center;
        }
        
        #level-stats {
            color: white;
            font-size: 18px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        #next-level {
            background-color: #f7931a;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
        }
        
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 999;
        }
        
        .loading-text {
            color: #f7931a;
            font-size: 24px;
        }
        
        .restart-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(247, 147, 26, 0.7);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div class="loading-overlay">
        <div class="loading-text">Loading Avuyile's World...</div>
    </div>
    
    <div id="start-screen">
        <h1>AVUYILE'S BITCOIN ADVENTURE</h1>
        <button id="start-button">START GAME</button>
    </div>
    
    <div id="level-complete">
        <h1>LEVEL COMPLETE!</h1>
        <div id="level-stats"></div>
        <button id="next-level">NEXT LEVEL</button>
    </div>
    
    <button class="restart-button" id="restart-button">RESTART</button>
    
    <div id="game-container"></div>
    
    <div id="ui-container">
        <div id="stats">
            <div>DEV: AVUYILE MTHEMBU</div>
            <div>BITCOIN: <span id="btc-count">0</span></div>
            <div>LEVEL: <span id="level-indicator">1</span></div>
        </div>
        <div id="message"></div>
    </div>
    
    <div class="controls">
        <div class="joystick-area">
            <div class="joystick-knob"></div>
        </div>
        <div class="action-buttons">
            <div id="jump-button" class="action-button">JUMP</div>
            <div id="action-button" class="action-button">CODE</div>
        </div>
    </div>
    
    <script>
        // Wait for Three.js to load
        window.addEventListener('load', init);
        
        // Global variables
        let scene, camera, renderer, clock;
        let player, playerCollider;
        let playerVelocity = null;
        let playerDirection = null;
        let playerOnFloor = false;
        let gravity = 30;
        let jumpVelocity = 12;
        let playerSpeed = 10;
        let bitcoins = [];
        let obstacles = [];
        let bitcoinCount = 0;
        let levelNumber = 1;
        let isJumping = false;
        let isGameActive = false;
        let finishLine = null;
        let bitcoinModels = [];
        
        // Touch controls
        let joystickActive = false;
        let joystickOrigin = { x: 0, y: 0 };
        let joystickPosition = { x: 0, y: 0 };
        let joystickKnob = null;
        let joystickArea = null;
        let jumpButton = null;
        let actionButton = null;
        
        // World state
        const world = {
            width: 50,
            depth: 100,
            floorY: -2,
        };
        
        // Particle system
        let particlesToUpdate = [];
        
        // Initialize game
        function init() {
            // Check if Three.js is loaded
            if (typeof THREE === 'undefined') {
                console.error('Three.js not loaded');
                document.querySelector('.loading-text').textContent = 'Error loading Three.js. Please refresh the page.';
                return;
            }
            
            // Initialize Three.js vectors
            playerVelocity = new THREE.Vector3();
            playerDirection = new THREE.Vector3();
            
            // Configure Three.js scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            
            // Set up camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, -10);
            camera.lookAt(0, 0, 10);
            
            // Set up renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            document.getElementById('game-container').appendChild(renderer.domElement);
            
            // Initialize clock for animations
            clock = new THREE.Clock();
            
            // Set up lighting
            setupLighting();
            
            // Create player
            createPlayer();
            
            // Create world
            createWorld();
            
            // Set up controls
            setupControls();
            
            // Set up event listeners
            window.addEventListener('resize', onWindowResize);
            
            // Hide loading screen
            setTimeout(() => {
                document.querySelector('.loading-overlay').style.display = 'none';
            }, 1000);
            
            // Start button listener
            document.getElementById('start-button').addEventListener('click', startGame);
            document.getElementById('next-level').addEventListener('click', nextLevel);
            document.getElementById('restart-button').addEventListener('click', restartGame);
            
            // Initial render
            animate();
        }
        
        function restartGame() {
            document.getElementById('level-complete').style.display = 'none';
            document.getElementById('start-screen').style.display = 'none';
            
            levelNumber = 1;
            document.getElementById('level-indicator').textContent = levelNumber;
            bitcoinCount = 0;
            document.getElementById('btc-count').textContent = bitcoinCount;
            
            isGameActive = true;
            initLevel(levelNumber);
        }
        
        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            isGameActive = true;
            initLevel(levelNumber);
        }
        
        function nextLevel() {
            document.getElementById('level-complete').style.display = 'none';
            levelNumber++;
            document.getElementById('level-indicator').textContent = levelNumber;
            bitcoinCount = 0;
            document.getElementById('btc-count').textContent = bitcoinCount;
            initLevel(levelNumber);
        }
        
        function setupLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            // Directional light (sun)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -25;
            directionalLight.shadow.camera.right = 25;
            directionalLight.shadow.camera.top = 25;
            directionalLight.shadow.camera.bottom = -25;
            scene.add(directionalLight);
        }
        
        function createPlayer() {
            // Create player body
            const playerGeometry = new THREE.BoxGeometry(1, 2, 1);
            const playerMaterial = new THREE.MeshLambertMaterial({ color: 0x1E90FF });
            player = new THREE.Mesh(playerGeometry, playerMaterial);
            player.position.set(0, 1, 0);
            player.castShadow = true;
            player.receiveShadow = true;
            scene.add(player);
            
            // Create player head
            const headGeometry = new THREE.SphereGeometry(0.4, 16, 16);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0x1E90FF });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1;
            player.add(head);
            
            // Add eyes
            const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.15, 0.1, 0.3);
            head.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.15, 0.1, 0.3);
            head.add(rightEye);
            
            const pupilGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const pupilMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            
            const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            leftPupil.position.z = 0.05;
            leftEye.add(leftPupil);
            
            const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            rightPupil.position.z = 0.05;
            rightEye.add(rightPupil);
            
            // Player collider
            playerCollider = new THREE.Box3().setFromObject(player);
        }
        
        function createWorld() {
            // Create floor
            const floorGeometry = new THREE.PlaneGeometry(world.width, world.depth);
            const floorMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x77a677,
                side: THREE.DoubleSide
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = Math.PI / 2;
            floor.position.y = world.floorY;
            floor.receiveShadow = true;
            scene.add(floor);
            
            // Add grid pattern to floor
            const gridHelper = new THREE.GridHelper(Math.max(world.width, world.depth), 20, 0x000000, 0x444444);
            gridHelper.position.y = world.floorY + 0.01;
            scene.add(gridHelper);
            
            // Create sky
            createSkyBox();
            
            // Add environment decorations
            addEnvironmentDecorations();
        }
        
        function createSkyBox() {
            const skyGeometry = new THREE.BoxGeometry(1000, 1000, 1000);
            const skyMaterials = Array(6).fill().map(() => 
                new THREE.MeshBasicMaterial({ 
                    color: 0x87CEEB, 
                    side: THREE.BackSide 
                })
            );
            const skyBox = new THREE.Mesh(skyGeometry, skyMaterials);
            scene.add(skyBox);
            
            // Add sun
            const sunGeometry = new THREE.SphereGeometry(20, 16, 16);
            const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const sun = new THREE.Mesh(sunGeometry, sunMaterial);
            sun.position.set(100, 100, -100);
            scene.add(sun);
            
            // Add clouds
            for (let i = 0; i < 20; i++) {
                createCloud(
                    Math.random() * 200 - 100,
                    Math.random() * 20 + 20,
                    Math.random() * 200 - 100
                );
            }
        }
        
        function createCloud(x, y, z) {
            const cloudGroup = new THREE.Group();
            const cloudMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            
            // Create several spheres to form a cloud
            const parts = 3 + Math.floor(Math.random() * 4);
            for (let i = 0; i < parts; i++) {
                const size = 2 + Math.random() * 3;
                const geometry = new THREE.SphereGeometry(size, 8, 8);
                const cloudPart = new THREE.Mesh(geometry, cloudMaterial);
                
                cloudPart.position.set(
                    Math.random() * 5 - 2.5,
                    Math.random() * 2 - 1,
                    Math.random() * 5 - 2.5
                );
                
                cloudGroup.add(cloudPart);
            }
            
            cloudGroup.position.set(x, y, z);
            scene.add(cloudGroup);
            
            // Make clouds move slowly
            cloudGroup.update = (delta) => {
                cloudGroup.position.x += delta * 2;
                if (cloudGroup.position.x > 100) {
                    cloudGroup.position.x = -100;
                }
            };
            
            particlesToUpdate.push(cloudGroup);
        }
        
        function addEnvironmentDecorations() {
            // Add some mountains in the background
            for (let i = 0; i < 7; i++) {
                const mountainGeometry = new THREE.ConeGeometry(8, 15, 4);
                const mountainMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
                const mountain = new THREE.Mesh(mountainGeometry, mountainMaterial);
                
                mountain.position.x = -30 + i * 10;
                mountain.position.y = 5;
                mountain.position.z = -40;
                mountain.receiveShadow = true;
                mountain.castShadow = true;
                scene.add(mountain);
                
                // Add snow cap
                const snowCapGeometry = new THREE.ConeGeometry(4, 3, 4);
                const snowCapMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
                const snowCap = new THREE.Mesh(snowCapGeometry, snowCapMaterial);
                snowCap.position.y = 6;
                mountain.add(snowCap);
            }
            
            // Add some trees
            for (let i = 0; i < 20; i++) {
                const treePosition = new THREE.Vector3(
                    Math.random() * 40 - 20,
                    0,
                    Math.random() * 80 - 40
                );
                
                // Ensure trees are not in the player's path
                if (Math.abs(treePosition.x) < 3 && treePosition.z > -5 && treePosition.z < 40) {
                    continue;
                }
                
                // Tree trunk
                const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.4, 2, 8);
                const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.copy(treePosition);
                trunk.position.y = world.floorY + 1;
                trunk.castShadow = true;
                scene.add(trunk);
                
                // Tree foliage
                const foliageGeometry = new THREE.ConeGeometry(1.5, 3, 8);
                const foliageMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                foliage.position.copy(treePosition);
                foliage.position.y = world.floorY + 3.5;
                foliage.castShadow = true;
                scene.add(foliage);
            }
            
            // Create bitcoin logo in the sky
            const btcLogoGroup = new THREE.Group();
            
            // Circle part
            const circleGeometry = new THREE.CircleGeometry(5, 32);
            const circleMaterial = new THREE.MeshBasicMaterial({ color: 0xf7931a });
            const circle = new THREE.Mesh(circleGeometry, circleMaterial);
            btcLogoGroup.add(circle);
            
            // Simplified B using basic shapes
            const bLine1 = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 3, 0.1),
                new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            bLine1.position.set(-2, 0, 0.1);
            btcLogoGroup.add(bLine1);
            
            const bCircle1 = new THREE.Mesh(
                new THREE.RingGeometry(0.8, 1.2, 16, 8, 0, Math.PI),
                new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide })
            );
            bCircle1.position.set(-0.8, 0.8, 0.1);
            bCircle1.rotation.z = Math.PI / 2;
            btcLogoGroup.add(bCircle1);
            
            const bCircle2 = new THREE.Mesh(
                new THREE.RingGeometry(0.8, 1.2, 16, 8, 0, Math.PI),
                new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide })
            );
            bCircle2.position.set(-0.8, -0.8, 0.1);
            bCircle2.rotation.z = Math.PI / 2;
            btcLogoGroup.add(bCircle2);
            
            btcLogoGroup.position.set(20, 20, -50);
            btcLogoGroup.rotation.y = -Math.PI / 6;
            scene.add(btcLogoGroup);
            
            // Make the logo rotate slowly
            btcLogoGroup.update = (delta) => {
                btcLogoGroup.rotation.y += delta * 0.2;
            };
            particlesToUpdate.push(btcLogoGroup);
        }
        
        function initLevel(level) {
            // Clear existing level elements
            clearLevel();
            
            // Set level-specific parameters
            const levelParams = getLevelParams(level);
            
            // Create obstacles
            for (let i = 0; i < levelParams.obstacles; i++) {
                createObstacle(
                    Math.random() * 16 - 8,   // x position
                    1,                        // y position
                    10 + i * (50 / levelParams.obstacles),  // z position - spread out evenly
                    1 + Math.random() * 2,    // width
                    1 + Math.random() * 2,    // height
                    1 + Math.random() * 1     // depth
                );
            }
            
            // Create bitcoins
            for (let i = 0; i < levelParams.bitcoins; i++) {
                createBitcoin(
                    Math.random() * 16 - 8,   // x position
                    1.5,                      // y position
                    5 + i * (levelParams.finishLine / (levelParams.bitcoins + 1)),  // z position - spread out
                );
            }
            
            // Create finish line
            finishLine = createFinishLine(0, 0, levelParams.finishLine);
            
            // Reset player position
            player.position.set(0, 1, 0);
            playerVelocity.set(0, 0, 0);
            
            // Display level message
            showMessage(`Level ${level}: Collect ${levelParams.requiredBitcoins} Bitcoins to complete the level`, 5000);
            
            // Reset camera
            camera.position.set(0, 5, -10);
            camera.lookAt(0, 0, 10);
            
            isGameActive = true;
        }
        
        function getLevelParams(level) {
            // Adjust difficulty based on level
            return {
                obstacles: 5 + level * 2,
                bitcoins: 5 + level,
                finishLine: 50 + level * 10,
                requiredBitcoins: Math.min(3 + level, 10) // Cap at 10 required bitcoins
            };
        }
        
        function clearLevel() {
            // Remove all bitcoins
            for (let bitcoin of bitcoins) {
                scene.remove(bitcoin);
            }
            bitcoins = [];
            bitcoinModels = [];
            
            // Remove all obstacles
            for (let obstacle of obstacles) {
                scene.remove(obstacle.mesh);
            }
            obstacles = [];
            
            // Reset bitcoin count
            bitcoinCount = 0;
            document.getElementById('btc-count').textContent = bitcoinCount;
            
            // Remove finish line
            if (finishLine) {
                scene.remove(finishLine.mesh);
                finishLine = null;
            }
        }
        
        function createBitcoin(x, y, z) {
            // Create a bitcoin coin with the â‚¿ symbol
            const bitcoinGroup = new THREE.Group();
            
            // Coin body - cylinder with proper gold color
            const coinGeometry = new THREE.CylinderGeometry(0.7, 0.7, 0.2, 32);
            const coinMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xf7931a,
                metalness: 0.8,
                roughness: 0.2
            });
            const coin = new THREE.Mesh(coinGeometry, coinMaterial);
            coin.rotation.x = Math.PI / 2;
            bitcoinGroup.add(coin);
            
            // Bitcoin symbol on the coin
            const symbolGeometry = new THREE.BoxGeometry(0.4, 0.8, 0.05);
            const symbolMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const symbol = new THREE.Mesh(symbolGeometry, symbolMaterial);
            symbol.position.z = 0.13;
            bitcoinGroup.add(symbol);
            
            // Position the bitcoin
            bitcoinGroup.position.set(x, y, z);
            scene.add(bitcoinGroup);
            
            // Add animation to rotate the bitcoin
            bitcoinGroup.userData = {
                rotationSpeed: 0.05 + Math.random() * 0.05,
                originalY: y,
                hoverAmplitude: 0.2,
                hoverSpeed: 2 + Math.random()
            };
            
            bitcoinGroup.update = (delta) => {
                // Rotate the bitcoin
                bitcoinGroup.rotation.y += bitcoinGroup.userData.rotationSpeed;
                
                // Make it hover up and down
                bitcoinGroup.position.y = bitcoinGroup.userData.originalY + 
                    Math.sin(Date.now() * 0.001 * bitcoinGroup.userData.hoverSpeed) * 
                    bitcoinGroup.userData.hoverAmplitude;
            };
            
            bitcoins.push(bitcoinGroup);
            bitcoinModels.push(bitcoinGroup);
            particlesToUpdate.push(bitcoinGroup);
            
            return bitcoinGroup;
        }
        
        function createObstacle(x, y, z, width, height, depth) {
            // Create a more interesting obstacle - a "code block"
            const obstacleGroup = new THREE.Group();
            
            // Main block
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshLambertMaterial({ 
                color: Math.random() > 0.5 ? 0x444444 : 0x555555 
            });
            const mesh = new THREE.Mesh(geometry, material);
            obstacleGroup.add(mesh);
            
            // Add some details to make it look like code
            const detailsCount = Math.floor(Math.random() * 4) + 2;
            for (let i = 0; i < detailsCount; i++) {
                const detailGeometry = new THREE.BoxGeometry(width * 0.7, 0.1, 0.05);
                const detailMaterial = new THREE.MeshBasicMaterial({ 
                    color: Math.random() > 0.3 ? 0x00ff00 : 0x00ffff 
                });
                const detail = new THREE.Mesh(detailGeometry, detailMaterial);
                detail.position.z = depth / 2 + 0.03;
                detail.position.y = height / 2 - 0.2 - i * 0.3;
                obstacleGroup.add(detail);
            }
            
            // Position the obstacle
            obstacleGroup.position.set(x, y + height / 2, z);
            scene.add(obstacleGroup);
            
            // Create collider
            const bbox = new THREE.Box3().setFromObject(obstacleGroup);
            
            const obstacle = {
                mesh: obstacleGroup,
                collider: bbox
            };
            
            obstacles.push(obstacle);
            
            return obstacle;
        }
        
        function createFinishLine(x, y, z) {
            // Create a more interesting finish line
            const finishGroup = new THREE.Group();
            
            // Arch structure
            const baseWidth = 10;
            const baseHeight = 7;
            
            // Left pillar
            const leftPillarGeometry = new THREE.BoxGeometry(1, baseHeight, 1);
            const pillarMaterial = new THREE.MeshLambertMaterial({ color: 0x00aa00 });
            const leftPillar = new THREE.Mesh(leftPillarGeometry, pillarMaterial);
            leftPillar.position.set(-baseWidth/2, baseHeight/2, 0);
            finishGroup.add(leftPillar);
            
            // Right pillar
            const rightPillarGeometry = new THREE.BoxGeometry(1, baseHeight, 1);
            const rightPillar = new THREE.Mesh(rightPillarGeometry, pillarMaterial);
            rightPillar.position.set(baseWidth/2, baseHeight/2, 0);
            finishGroup.add(rightPillar);
            
            // Top arch
            const topArchGeometry = new THREE.BoxGeometry(baseWidth, 1, 1);
            const topArchMaterial = new THREE.MeshLambertMaterial({ color: 0xf7931a });
            const topArch = new THREE.Mesh(topArchGeometry, topArchMaterial);
            topArch.position.set(0, baseHeight, 0);
            finishGroup.add(topArch);
            
            // Create "FINISH" text - simplified using blocks
            for (let i = 0; i < 6; i++) {
                const letterBox = new THREE.Mesh(
                    new THREE.BoxGeometry(0.8, 0.8, 0.2),
                    new THREE.MeshBasicMaterial({ color: 0xffffff })
                );
                letterBox.position.set(-baseWidth/2 + 1.5 + i * 1.5, baseHeight - 0.5, 0.6);
                finishGroup.add(letterBox);
            }
            
            // Add some decorative details
            for (let i = 0; i < 10; i++) {
                const flagGeometry = new THREE.BoxGeometry(0.1, 1, 0.5);
                const flagMaterial = new THREE.MeshLambertMaterial({ 
                    color: i % 2 === 0 ? 0xf7931a : 0xffffff 
                });
                const flag = new THREE.Mesh(flagGeometry, flagMaterial);
                
                if (i < 5) {
                    flag.position.set(-baseWidth/2 - 0.5, baseHeight - i, 0);
                } else {
                    flag.position.set(baseWidth/2 + 0.5, baseHeight - (i-5), 0);
                }
                
                finishGroup.add(flag);
            }
            
            // Position the finish line
            finishGroup.position.set(x, y, z);
            scene.add(finishGroup);
            
            // Create collider (slightly wider than visual to make it easier to hit)
            const bbox = new THREE.Box3();
            bbox.setFromObject(finishGroup);
            bbox.expandByVector(new THREE.Vector3(2, 0, 2)); // Make it a bit bigger
            
            const finishLineObj = {
                mesh: finishGroup,
                collider: bbox,
                isFinishLine: true
            };
            
            obstacles.push(finishLineObj);
            
            return finishLineObj;
        }
        
        function setupControls() {
            joystickArea = document.querySelector('.joystick-area');
            joystickKnob = document.querySelector('.joystick-knob');
            jumpButton = document.getElementById('jump-button');
            actionButton = document.getElementById('action-button');
            
            // Touch events for joystick
            joystickArea.addEventListener('touchstart', onJoystickStart);
            document.addEventListener('touchmove', onJoystickMove);
            document.addEventListener('touchend', onJoystickEnd);
            
            // Jump button
            jumpButton.addEventListener('touchstart', onJump);
            
            // Action button
            actionButton.addEventListener('touchstart', onAction);
            
            // Add keyboard controls for testing on desktop
            document.addEventListener('keydown', function(event) {
                if (!isGameActive) return;
                
                switch(event.key) {
                    case 'ArrowUp':
                        playerDirection.z = 1;
                        break;
                    case 'ArrowDown':
                        playerDirection.z = -1;
                        break;
                    case 'ArrowLeft':
                        playerDirection.x = 1;
                        break;
                    case 'ArrowRight':
                        playerDirection.x = -1;
                        break;
                    case ' ':
                        onJump(event);
                        break;
                    case 'c':
                        onAction(event);
                        break;
                }
            });
            
            document.addEventListener('keyup', function(event) {
                switch(event.key) {
                    case 'ArrowUp':
                    case 'ArrowDown':
                        playerDirection.z = 0;
                        break;
                    case 'ArrowLeft':
                    case 'ArrowRight':
                        playerDirection.x = 0;
                        break;
                }
            });
        }
        
        function onJoystickStart(event) {
            event.preventDefault();
            joystickActive = true;
            
            const touch = event.touches[0];
            const rect = joystickArea.getBoundingClientRect();
            
            joystickOrigin = {
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2
            };
            
            joystickPosition = {
                x: touch.clientX,
                y: touch.clientY
            };
            
            updateJoystick();
        }
        
        function onJoystickMove(event) {
            if (!joystickActive) return;
            event.preventDefault();
            
            const touch = Array.from(event.touches).find(t => {
                const rect = joystickArea.getBoundingClientRect();
                return (
                    t.clientX >= rect.left - 50 && 
                    t.clientX <= rect.right + 50 && 
                    t.clientY >= rect.top - 50 && 
                    t.clientY <= rect.bottom + 50
                );
            });
            
            if (!touch) return;
            
            joystickPosition = {
                x: touch.clientX,
                y: touch.clientY
            };
            
            updateJoystick();
        }
        
        function onJoystickEnd(event) {
            const rect = joystickArea.getBoundingClientRect();
            
            // Only reset joystick if all touches are gone or none are near the joystick
            if (event.touches.length === 0 || !Array.from(event.touches).some(t => {
                return (
                    t.clientX >= rect.left - 50 && 
                    t.clientX <= rect.right + 50 && 
                    t.clientY >= rect.top - 50 && 
                    t.clientY <= rect.bottom + 50
                );
            })) {
                joystickActive = false;
                joystickKnob.style.transform = 'translate(-50%, -50%)';
                playerDirection.x = 0;
                playerDirection.z = 0;
            }
        }
        
        function updateJoystick() {
            const maxDistance = 40;
            
            let dx = joystickPosition.x - joystickOrigin.x;
            let dy = joystickPosition.y - joystickOrigin.y;
            
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > maxDistance) {
                dx = dx * maxDistance / distance;
                dy = dy * maxDistance / distance;
            }
            
            joystickKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
            
            // Update player direction based on joystick position
            playerDirection.x = dx / maxDistance;
            playerDirection.z = dy / maxDistance;
        }
        
        function onJump(event) {
            if (event) event.preventDefault();
            if (playerOnFloor && isGameActive) {
                playerVelocity.y = jumpVelocity;
                playerOnFloor = false;
                isJumping = true;
            }
        }
        
        function onAction(event) {
            if (event) event.preventDefault();
            if (isGameActive) {
                // Perform a "coding" action - emit particles
                createCodeParticles();
            }
        }
        
        function createCodeParticles() {
            // Create coding particles
            for (let i = 0; i < 20; i++) {
                // Different colored particles for code effect
                const colors = [0x00ff00, 0x00ffff, 0xffff00];
                const particleGeometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                const particleMaterial = new THREE.MeshBasicMaterial({ 
                    color: colors[Math.floor(Math.random() * colors.length)] 
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                particle.position.copy(player.position);
                particle.position.y += 1;
                
                // Random velocity
                particle.velocity = new THREE.Vector3(
                    Math.random() * 4 - 2,
                    Math.random() * 4,
                    Math.random() * 4 - 2
                );
                
                particle.rotationSpeed = {
                    x: Math.random() * 0.1,
                    y: Math.random() * 0.1,
                    z: Math.random() * 0.1
                };
                
                scene.add(particle);
                
                // Remove particle after 1 second
                setTimeout(() => {
                    scene.remove(particle);
                    const index = particlesToUpdate.indexOf(particle);
                    if (index !== -1) {
                        particlesToUpdate.splice(index, 1);
                    }
                }, 1000);
                
                // Update particle position in animation loop
                particle.update = (delta) => {
                    particle.position.x += particle.velocity.x * delta;
                    particle.position.y += particle.velocity.y * delta;
                    particle.position.z += particle.velocity.z * delta;
                    particle.velocity.y -= gravity * delta * 0.1; // Apply gravity
                    
                    // Rotate particle
                    particle.rotation.x += particle.rotationSpeed.x;
                    particle.rotation.y += particle.rotationSpeed.y;
                    particle.rotation.z += particle.rotationSpeed.z;
                    
                    // Gradually fade out particle by scaling down
                    particle.scale.multiplyScalar(0.99);
                };
                
                // Add to update list
                particlesToUpdate.push(particle);
            }
        }
        
        function updatePlayer(delta) {
            if (!isGameActive) return;
            
            // Apply gravity
            playerVelocity.y -= gravity * delta;
            
            // Update player position based on velocity
            player.position.x += playerVelocity.x * delta;
            player.position.y += playerVelocity.y * delta;
            player.position.z += playerVelocity.z * delta;
            
            // Move player based on joystick/keyboard
            const moveX = playerDirection.x * playerSpeed * delta;
            const moveZ = playerDirection.z * playerSpeed * delta;
            
            player.position.x += moveX;
            player.position.z += moveZ;
            
            // Rotate player based on movement direction
            if (Math.abs(moveX) > 0.01 || Math.abs(moveZ) > 0.01) {
                player.rotation.y = Math.atan2(moveX, moveZ);
            }
            
            // Keep player within bounds
            player.position.x = Math.max(-world.width / 2 + 1, Math.min(world.width / 2 - 1, player.position.x));
            
            // Update player collider
            playerCollider.setFromObject(player);
            
            // Check floor collision
            if (player.position.y < world.floorY + 1) {
                player.position.y = world.floorY + 1;
                playerVelocity.y = 0;
                playerOnFloor = true;
                isJumping = false;
            }
            
            // Camera follows player
            camera.position.x = player.position.x * 0.8;
            camera.position.y = player.position.y + 5;
            camera.position.z = player.position.z - 10;
            camera.lookAt(player.position.x, player.position.y, player.position.z + 10);
            
            // Check for collisions with bitcoins
            checkBitcoinCollisions();
            
            // Check for collisions with obstacles
            checkObstacleCollisions();
            
            // Update player animation
            if (playerOnFloor) {
                // Simulate walking animation
                if (Math.abs(playerDirection.x) > 0.1 || Math.abs(playerDirection.z) > 0.1) {
                    player.position.y = world.floorY + 1 + Math.sin(Date.now() * 0.01) * 0.1;
                }
            } else {
                // Simulate jumping animation
                player.rotation.x = Math.sin(Date.now() * 0.01) * 0.1;
            }
        }
        
        function checkBitcoinCollisions() {
            // Check each bitcoin
            for (let i = bitcoins.length - 1; i >= 0; i--) {
                const bitcoin = bitcoins[i];
                
                // Simple distance check
                if (player.position.distanceTo(bitcoin.position) < 1.5) {
                    // Collect bitcoin
                    scene.remove(bitcoin);
                    bitcoins.splice(i, 1);
                    bitcoinCount++;
                    document.getElementById('btc-count').textContent = bitcoinCount;
                    
                    // Create collection effect
                    createBitcoinCollectEffect(bitcoin.position);
                    
                    // Play collection sound effect
                    playCollectionSound();
                }
            }
        }
        
        function playCollectionSound() {
            // Visual feedback
            const message = document.getElementById('message');
            message.textContent = "+1 BITCOIN!";
            message.style.opacity = 1;
            message.style.color = "#f7931a";
            
            setTimeout(() => {
                message.style.opacity = 0;
            }, 1000);
        }
        
        function createBitcoinCollectEffect(position) {
            // Create sparkle effect for bitcoin collection
            for (let i = 0; i < 15; i++) {
                const particleGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
                const particleMaterial = new THREE.MeshBasicMaterial({ color: 0xf7931a });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                particle.position.copy(position);
                
                // Random velocity in all directions
                particle.velocity = new THREE.Vector3(
                    Math.random() * 4 - 2,
                    Math.random() * 6,
                    Math.random() * 4 - 2
                );
                
                particle.rotationSpeed = {
                    x: Math.random() * 0.2,
                    y: Math.random() * 0.2,
                    z: Math.random() * 0.2
                };
                
                scene.add(particle);
                
                // Remove particle after 1 second
                setTimeout(() => {
                    scene.remove(particle);
                    const index = particlesToUpdate.indexOf(particle);
                    if (index !== -1) {
                        particlesToUpdate.splice(index, 1);
                    }
                }, 1000);
                
                // Update particle position in animation loop
                particle.update = (delta) => {
                    particle.position.x += particle.velocity.x * delta;
                    particle.position.y += particle.velocity.y * delta;
                    particle.position.z += particle.velocity.z * delta;
                    particle.velocity.y -= gravity * delta * 0.1; // Apply gravity
                    
                    // Rotate particle
                    particle.rotation.x += particle.rotationSpeed.x;
                    particle.rotation.y += particle.rotationSpeed.y;
                    particle.rotation.z += particle.rotationSpeed.z;
                    
                    // Gradually fade out particle
                    particle.scale.multiplyScalar(0.97);
                };
                
                // Add to update list
                particlesToUpdate.push(particle);
            }
        }
        
        function checkObstacleCollisions() {
            for (let obstacle of obstacles) {
                // Update obstacle collider (in case it moved)
                obstacle.collider.setFromObject(obstacle.mesh);
                
                if (playerCollider.intersectsBox(obstacle.collider)) {
                    if (obstacle.isFinishLine) {
                        // Check if player has collected enough bitcoins
                        const requiredBitcoins = getLevelParams(levelNumber).requiredBitcoins;
                        if (bitcoinCount >= requiredBitcoins) {
                            // Level complete
                            levelComplete();
                        } else {
                            // Not enough bitcoins
                            showMessage(`Need ${requiredBitcoins} bitcoins to complete level!`, 3000);
                        }
                    } else {
                        // Handle obstacle collision
                        handleObstacleCollision(obstacle);
                    }
                }
            }
        }
        
        function handleObstacleCollision(obstacle) {
            // Simple bounce effect
            const obstacleCenter = new THREE.Vector3();
            obstacle.collider.getCenter(obstacleCenter);
            
            const direction = new THREE.Vector3().subVectors(player.position, obstacleCenter).normalize();
            
            // Push player away from obstacle
            player.position.add(direction.multiplyScalar(0.2));
            
            // Bounce effect
            if (direction.y > 0.5) {
                playerVelocity.y = Math.max(playerVelocity.y, 8);
            } else {
                // Horizontal collision
                playerVelocity.x = direction.x * 8;
                playerVelocity.z = direction.z * 8;
            }
            
            // Visual feedback for collision
            createCollisionEffect(player.position);
        }
        
        function createCollisionEffect(position) {
            // Create dust/impact effect
            for (let i = 0; i < 10; i++) {
                const particleGeometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                const particleMaterial = new THREE.MeshBasicMaterial({ color: 0xaaaaaa });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                particle.position.copy(position);
                
                // Random velocity primarily outward
                particle.velocity = new THREE.Vector3(
                    Math.random() * 6 - 3,
                    Math.random() * 4,
                    Math.random() * 6 - 3
                );
                
                scene.add(particle);
                
                // Remove particle after 700ms
                setTimeout(() => {
                    scene.remove(particle);
                    const index = particlesToUpdate.indexOf(particle);
                    if (index !== -1) {
                        particlesToUpdate.splice(index, 1);
                    }
                }, 700);
                
                // Update particle position in animation loop
                particle.update = (delta) => {
                    particle.position.x += particle.velocity.x * delta;
                    particle.position.y += particle.velocity.y * delta;
                    particle.position.z += particle.velocity.z * delta;
                    particle.velocity.y -= gravity * delta * 0.2; // Apply gravity
                    
                    // Gradually fade out particle
                    particle.scale.multiplyScalar(0.95);
                };
                
                // Add to update list
                particlesToUpdate.push(particle);
            }
        }
        
        function levelComplete() {
            isGameActive = false;
            
            // Update level stats display
            const levelStats = document.getElementById('level-stats');
            levelStats.innerHTML = `
                <p>Bitcoins collected: ${bitcoinCount}</p>
                <p>Level ${levelNumber} completed!</p>
            `;
            
            // Create celebration effect
            createCelebrationEffect();
            
            // Show level complete screen
            document.getElementById('level-complete').style.display = 'flex';
        }
        
        function createCelebrationEffect() {
            // Create fireworks effect
            for (let j = 0; j < 5; j++) {
                setTimeout(() => {
                    // Create explosion at random position above player
                    const explosionPos = new THREE.Vector3(
                        player.position.x + Math.random() * 10 - 5,
                        player.position.y + 10 + Math.random() * 5,
                        player.position.z + Math.random() * 10 - 5
                    );
                    
                    const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0xf7931a];
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    
                    for (let i = 0; i < 30; i++) {
                        const particleGeometry = new THREE.SphereGeometry(0.2, 8, 8);
                        const particleMaterial = new THREE.MeshBasicMaterial({ color });
                        const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                        
                        particle.position.copy(explosionPos);
                        
                        const angle = Math.random() * Math.PI * 2;
                        const height = Math.random() * Math.PI - Math.PI/2;
                        const speed = 2 + Math.random() * 3;
                        
                        particle.velocity = new THREE.Vector3(
                            Math.cos(angle) * Math.cos(height) * speed,
                            Math.sin(height) * speed,
                            Math.sin(angle) * Math.cos(height) * speed
                        );
                        
                        scene.add(particle);
                        
                        setTimeout(() => {
                            scene.remove(particle);
                            const index = particlesToUpdate.indexOf(particle);
                            if (index !== -1) {
                                particlesToUpdate.splice(index, 1);
                            }
                        }, 2000);
                        
                        // Update particle position in animation loop
                        particle.update = (delta) => {
                            particle.position.x += particle.velocity.x * delta;
                            particle.position.y += particle.velocity.y * delta;
                            particle.position.z += particle.velocity.z * delta;
                            particle.velocity.y -= gravity * delta * 0.1; // Apply gravity
                            
                            // Fade out particle
                            if (particle.scale.x > 0.01) {
                                particle.scale.multiplyScalar(0.99);
                            }
                        };
                        
                        // Add to update list
                        particlesToUpdate.push(particle);
                    }
                }, j * 300); // Stagger explosions
            }
        }
        
        function showMessage(text, duration) {
            const messageElement = document.getElementById('message');
            messageElement.textContent = text;
            messageElement.style.color = "#ffffff";
            messageElement.style.opacity = 1;
            
            setTimeout(() => {
                messageElement.style.opacity = 0;
            }, duration);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function updateParticles(delta) {
            for (let i = particlesToUpdate.length - 1; i >= 0; i--) {
                const particle = particlesToUpdate[i];
                
                if (particle.update) {
                    particle.update(delta);
                }
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = Math.min(clock.getDelta(), 0.1);
            
            updatePlayer(delta);
            updateParticles(delta);
            
            // Update bitcoins
            for (let bitcoin of bitcoinModels) {
                if (bitcoin.update) {
                    bitcoin.update(delta);
                }
            }
            
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
